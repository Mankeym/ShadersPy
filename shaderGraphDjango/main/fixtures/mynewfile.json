[{"model":"main.shader","pk":1,"fields":{"title":"₁ Position (Block)","textEng":"The Position block defines the position of each vertex on a mesh. If left unchanged, each vertex position will be the same as they do in your modelling program, but we can modify this Vector 3 to physically change the location of vertices in the world. You can use this for any effect which requires physically moving the mesh, such as ocean waves, but unfortunately, we can’t modify positions of individual pixels/fragments, only vertices.","textRus":"Блок Position определяет положение каждой вершины на сетке. Если оставить без изменений, положение каждой вершины будет таким же, как в вашей программе моделирования, но мы можем изменить этот Вектор 3, чтобы физически изменить расположение вершин в мире. Вы можете использовать это для любого эффекта, который требует физического перемещения сетки, например океанских волн, но, к сожалению, мы не можем изменять положения отдельных пикселей/фрагментов, а только вершины."}},{"model":"main.shader","pk":2,"fields":{"title":"₂ Normal (Block)","textEng":"The Normal block defines the direction the vertex normal points in. This direction is key to many lighting calculations, so changing this may change the way lighting interacts with the object. We can change this per-pixel in the fragment stage with another block node, unlike the Position. As with the Position block, this is a Vector 3.","textRus":"Блок Normal определяет направление, в котором указывает нормаль вершины. Это направление является ключевым для многих расчетов освещения, поэтому его изменение может изменить способ взаимодействия освещения с объектом. Мы можем изменить это значение для каждого пикселя на этапе фрагмента с помощью другого узла блока, в отличие от Position. Как и в случае с блоком «Положение», это вектор 3."}},{"model":"main.shader","pk":3,"fields":{"title":"₃ Tangent (Block)","textEng":"The tangent vector lies perpendicular to the vertex normal, and for a flat surface, it usually rests on the surface of the object. We can modify the Tangent block to change the tangent vector - I recommend you change this if you change the vertex normal so that it is still perpendicular. This is also a Vector 3.","textRus":"Вектор касательной лежит перпендикулярно нормали вершины и для плоской поверхности обычно опирается на поверхность объекта. Мы можем изменить блок касательной, чтобы изменить вектор касательной — я рекомендую вам изменить это, если вы измените нормаль вершины, чтобы она по-прежнему была перпендикулярной. Это тоже Вектор 3."}},{"model":"main.shader","pk":4,"fields":{"title":"₄ Base Color (Block)","textEng":"This was called Albedo in some versions of Shader Graph. The Base Color would be the color of the object if all lighting, transparency and other effects were taken out of the equation.","textRus":"В некоторых версиях Shader Graph это называлось Альбедо. Базовый цвет был бы цветом объекта, если бы из уравнения было исключено все освещение, прозрачность и другие эффекты."}},{"model":"main.shader","pk":5,"fields":{"title":"₅ Normal (Tangent/Object/World) (Block)","textEng":"As we saw, the vertex stage has its own normal block - we can access that normal, make further modifications per-pixel, and return a new normal vector for Unity’s built-in lighting calculations. There are three blocks called Normal, which is a bit confusing, but each one just expects a normal vector in a different space - tangent, object or world. Only one can be active at a time - select the one you want in the Graph Settings using the Fragment Normal Space option.","textRus":"Как мы видели, у стадии вершин есть свой собственный блок нормалей — мы можем получить доступ к этому нормали, внести дальнейшие изменения для каждого пикселя и вернуть новый вектор нормали для встроенных вычислений освещения Unity. Есть три блока под названием Normal, что немного сбивает с толку, но каждый из них просто ожидает вектор нормали в другом пространстве — касательной, объекте или мире. Одновременно может быть активен только один — выберите нужный в настройках графика, используя опцию «Обычное пространство фрагмента»."}},{"model":"main.shader","pk":6,"fields":{"title":"₆ Emission (Block)","textEng":"Emissive light is great for creating bloom around objects. Think neon lights, glowing flames, or magic spells. The Emission block accepts an HDR color, which gives us the ability to ramp up the intensity of a light far beyond what colors usually allow.","textRus":"Эмиссионный свет отлично подходит для создания цветения вокруг объектов. Подумайте о неоновых огнях, светящемся пламени или магических заклинаниях. Блок Emission принимает цвет HDR, что дает нам возможность увеличивать интенсивность света далеко за пределы того, что обычно позволяют цвета."}},{"model":"main.shader","pk":7,"fields":{"title":"₇ Metallic (Block)","textEng":"The Metallic block expects a float. When it is 0, the lighting on the objects acts as if it is completely non-metallic, and when it is 1, the object is totally metallic. This only has an effect when using a Metallic workflow - choose between this and Specular using the Workflow option in the Graph Settings (your material must be Lit for the option to appear).","textRus":"Блок Metallic ожидает плавающего курса. Когда он равен 0, освещение на объектах действует так, как будто оно полностью неметаллическое, а когда оно равно 1, объект полностью металлический. Это имеет эффект только при использовании рабочего процесса «Металлик» — выберите между этим и «Зеркальным», используя параметр «Рабочий процесс» в настройках графика (ваш материал должен быть освещен, чтобы эта опция появилась)."}},{"model":"main.shader","pk":8,"fields":{"title":"₈ Specular (Block)","textEng":"Unlike Metallic, the Specular block expects a color as input, because specular highlights can be tinted different colors. The brighter the color, and the closer to white the color is, the larger the highlights.","textRus":"В отличие от Metallic, блок Specular ожидает ввода цвета, поскольку зеркальные блики могут быть окрашены в разные цвета. Чем ярче цвет и чем ближе он к белому, тем больше бликов."}},{"model":"main.shader","pk":9,"fields":{"title":"₉ Smoothness (Block)","textEng":"The smoother an object, the more visible lighting highlights are. When Smoothness is 0, the surface lighting acts rough and matte. When it is 1, the surface acts like it’s polished to a mirror sheen.","textRus":"Чем более гладкий объект, тем более заметны световые блики. Когда Smoothness равно 0, освещение поверхности выглядит грубым и матовым. Когда он равен 1, поверхность ведет себя так, как будто она отполирована до зеркального блеска."}},{"model":"main.shader","pk":10,"fields":{"title":"₁₀ Ambient Occlusion (Block)","textEng":"Ambient Occlusion is a measure of how obscured a pixel is from light sources by other objects in the scene, such as walls. This is a float - when it is 0, the pixel should be fully lit according to whatever lighting falls on it. When it is 1, the lighting is artificially reduced to the minimum amount.","textRus":"Ambient Occlusion — это мера того, насколько пиксель скрыт от источников света другими объектами сцены, например стенами. Это число с плавающей запятой — когда оно равно 0, пиксель должен быть полностью освещен в зависимости от того, какое освещение на него падает. Когда он равен 1, освещение искусственно снижается до минимального уровня."}},{"model":"main.shader","pk":11,"fields":{"title":"₁₁ Alpha (Block)","textEng":"Alpha is a measure of how transparent a pixel is, and like many other blocks, it runs from 0 to 1, where 0 is totally transparent and 1 is fully opaque. Rendering transparency is more computationally expensive than rendering opaque objects, so we need to pick the Transparent Surface option in the Graph Settings for Unity to treat this shader properly.","textRus":"Альфа — это мера прозрачности пикселя, и, как и многие другие блоки, она изменяется от 0 до 1, где 0 — полностью прозрачен, а 1 — полностью непрозрачен. Рендеринг прозрачности требует больше вычислительных затрат, чем рендеринг непрозрачных объектов, поэтому нам нужно выбрать параметр «Прозрачная поверхность» в настройках графика для Unity, чтобы правильно обработать этот шейдер."}},{"model":"main.shader","pk":12,"fields":{"title":"₁₂ Alpha Clip Threshold (Block)","textEng":"Alpha clipping is a technique where pixels with an alpha below a specific threshold get culled. We can enable the Alpha Clip Threshold block in the Graph Settings by ticking the Alpha Clip option. This works regardless of whether the Surface is set to Transparent or Opaque, so the Alpha block isn’t always completely useless on opaque materials! This is useful for fake-transparency effects where opaque rendering is used, but pixels are culled in a pattern to create the illusion of transparency.","textRus":"Альфа-отсечение — это метод, при котором отбираются пиксели с альфа-каналом ниже определенного порога. Мы можем включить блок «Порог альфа-клипа» в настройках графика, отметив опцию «Альфа-клип». Это работает независимо от того, установлено ли для поверхности значение «Прозрачная» или «Непрозрачная», поэтому блок «Альфа» не всегда совершенно бесполезен для непрозрачных материалов! Это полезно для эффектов ложной прозрачности, когда используется непрозрачный рендеринг, но пиксели отбираются по шаблону, чтобы создать иллюзию прозрачности."}},{"model":"main.shader","pk":13,"fields":{"title":"₁₃ Float/Vector 1 (Property)","textEng":"A Float (or Vector 1 as they’re called in earlier versions of Shader Graph) is a single floating-point value. As with every variable type, we can change its Name - a human-readable name that will appear on the graph - and its Reference string, which is a different name we use to refer to shader variables inside C# scripts. The convention for reference strings is usually an underscore followed by words starting with capitals, with no spaces (such as _MainTex for a property called “Main Texture”).","textRus":"Число с плавающей запятой (или вектор 1, как они назывались в более ранних версиях Shader Graph) — это одно значение с плавающей запятой. Как и в случае с любым типом переменной, мы можем изменить ее имя (удобочитаемое имя, которое будет отображаться на графике) и ее ссылочную строку, которая представляет собой другое имя, которое мы используем для ссылки на переменные шейдера внутри сценариев C#. По соглашению для ссылочных строк обычно используется подчеркивание, за которым следуют слова, начинающиеся с заглавной буквы, без пробелов (например, _MainTex для свойства под названием «Основная текстура»)."}},{"model":"main.shader","pk":14,"fields":{"title":"₁₄ Vector 2 (Property)","textEng":"Vector 2 is like two Floats bolted together - they have an X and Y component. There’s no alternative modes like there were for Float, but we have the same Name, Reference, Default, Precision, Exposed and Override Property Declaration settings as Float.","textRus":"Вектор 2 подобен двум скрепленным вместе поплавкам — у них есть компоненты X и Y. Альтернативных режимов, подобных Float, нет, но у нас есть те же настройки имени, ссылки, по умолчанию, точности, раскрытия и переопределения свойства, что и у Float."}},{"model":"main.shader","pk":15,"fields":{"title":"₁₅ Vector 3 (Property)","textEng":"Vector 3 properties have an added Z component to work with. You can use Vector 3 to represent position or direction vectors within a 3D space, which you’ll end up doing a lot if you’re making shaders for 3D objects.","textRus":"Свойства Vector 3 имеют добавленный компонент Z для работы. Вы можете использовать Vector 3 для представления векторов положения или направления в трехмерном пространстве, что вам придется часто делать, если вы создаете шейдеры для трехмерных объектов."}},{"model":"main.shader","pk":16,"fields":{"title":"₁₆ Vector 4 (Property)","textEng":"And Vector 4 adds a W component. You could use this to pack arbitrary bits of data into the same variable.","textRus":"А Вектор 4 добавляет компонент W. Вы можете использовать это для упаковки произвольных битов данных в одну и ту же переменную."}},{"model":"main.shader","pk":17,"fields":{"title":"₁₇ Color (Property)","textEng":"The Color property type has a Mode toggle between Default and HDR. If we pick HDR, then we get extra options in the color window - we will cover these more fully when we discuss the Color node.","textRus":"Тип свойства «Цвет» имеет переключатель режима между «По умолчанию» и «HDR». Если мы выберем HDR, мы получим дополнительные параметры в окне цвета — мы рассмотрим их более подробно, когда будем обсуждать узел «Цвет»."}},{"model":"main.shader","pk":18,"fields":{"title":"₁₈ Boolean (Property)","textEng":"A Boolean property can be either True or False, which is controlled using the tickbox. There’s a group of nodes which use Boolean logic - we will talk about those near the end of the article.","textRus":"Логическое свойство может иметь значение True или False, что контролируется с помощью флажка. Есть группа узлов, использующих булевую логику — о них мы поговорим ближе к концу статьи."}},{"model":"main.shader","pk":19,"fields":{"title":"₁₉ Gradient (Property)","textEng":"Gradients work similarly here as they do anywhere else in the Unity Editor - we can add or remove handles from the gradient window to set the color (bottom row) or alpha (top row) of the gradient at that point. The Exposed checkbox is greyed out, so this property type can’t be exposed to the Inspector.","textRus":"Градиенты здесь работают так же, как и везде в редакторе Unity — мы можем добавлять или удалять маркеры из окна градиента, чтобы установить цвет (нижний ряд) или альфу (верхний ряд) градиента в этой точке. Флажок «Выставлено» неактивен, поэтому этот тип свойства не может быть доступен инспектору."}},{"model":"main.shader","pk":20,"fields":{"title":"₂₀ Texture 2D (Property)","textEng":"The Texture 2D property type lets us declare a Texture 2D asset that we want to use in the graph. The Mode drop-down gives us three default color options for when no texture is selected: White, Grey or Black. There’s also a Bump option which can be used for completely flat normal maps, which are blue.","textRus":"Тип свойства «Текстура 2D» позволяет нам объявить ресурс «Текстура 2D», который мы хотим использовать в графике. В раскрывающемся списке «Режим» есть три варианта цвета по умолчанию, когда текстура не выбрана: белый, серый или черный. Существует также опция Bump, которую можно использовать для совершенно плоских карт нормалей синего цвета."}},{"model":"main.shader","pk":21,"fields":{"title":"₂₁ Texture 2D Array (Property)","textEng":"A Texture 2D Array is a collection of 2D textures with the same size and format that have been packaged together so that the GPU can read them as if they are a single texture, for increased efficiency. We can sample them using special nodes, as we’ll see later.","textRus":"Массив текстур 2D — это набор 2D-текстур одинакового размера и формата, которые были упакованы вместе, чтобы графический процессор мог читать их, как если бы они представляли собой одну текстуру, для повышения эффективности. Как мы увидим позже, мы можем выполнить их выборку, используя специальные узлы."}},{"model":"main.shader","pk":22,"fields":{"title":"₂₂ Texture 3D (Property)","textEng":"A Texture 3D is similar to Texture 2D, but we have an added dimension - it’s like a 3D block of color data. Unlike Texture 2D, don’t have access to a Mode option.","textRus":"Текстура 3D похожа на Текстуру 2D, но у нас есть дополнительное измерение — это похоже на трехмерный блок цветовых данных. В отличие от текстуры 2D, у нее нет доступа к опции «Режим»."}},{"model":"main.shader","pk":23,"fields":{"title":"₂₃ Cubemap (Property)","textEng":"A Cubemap is a special texture type which is conceptually like the net of a cube - think of them as six textures which have been stitched together. They are useful for skyboxes and reflection mapping.","textRus":"Кубическая карта — это особый тип текстуры, который концептуально похож на сетку куба — думайте о них как о шести текстурах, сшитых вместе. Они полезны для скайбоксов и отображения отражений."}},{"model":"main.shader","pk":24,"fields":{"title":"₂₄ Virtual Texture (Property)","textEng":"Virtual Textures can be used to reduce memory usage if you’re using several high-res textures, but they’re only supported by HDRP. On URP, using them won’t yield performance benefits over sampling those textures like usual. We can add or remove up to four textures from the stack, although I’m unsure if this number varies by hardware or other settings.","textRus":"Виртуальные текстуры можно использовать для уменьшения использования памяти, если вы используете несколько текстур высокого разрешения, но они поддерживаются только HDRP. В URP их использование не даст преимущества в производительности по сравнению с обычной выборкой этих текстур. Мы можем добавить или удалить из стека до четырех текстур, хотя я не уверен, зависит ли это число от аппаратного обеспечения или других настроек."}},{"model":"main.shader","pk":25,"fields":{"title":"₂₅ Matrix 2 (Property)","textEng":"A Matrix 2 is a 2x2 grid of floating-point numbers. When you create a new property of this type, its value will be the 2x2 identity matrix, which has ones down the leading diagonal and zeroes elsewhere.","textRus":"Матрица 2 представляет собой сетку чисел с плавающей запятой размером 2x2. Когда вы создаете новое свойство этого типа, его значением будет единичная матрица 2x2, в которой есть единицы на главной диагонали и нули в остальных местах."}},{"model":"main.shader","pk":26,"fields":{"title":"₂₆ Matrix 3 (Property)","textEng":"A Matrix 3 is slightly larger than a Matrix 2 - it’s a 3x3 grid of numbers.","textRus":"Матрица 3 немного больше Матрицы 2 — это сетка чисел 3x3."}},{"model":"main.shader","pk":27,"fields":{"title":"₂₇ Matrix 4 (Property)","textEng":"And a Matrix 4 is a 4x4 grid of floats. Matrices are useful for transforming vectors in your graph in interesting ways, but none of the three matrix types can be exposed to the Inspector.","textRus":"Матрица 4 представляет собой сетку поплавков 4x4. Матрицы полезны для интересных способов преобразования векторов в графике, но ни один из трех типов матриц не может быть доступен Инспектору."}},{"model":"main.shader","pk":28,"fields":{"title":"₂₈ Sampler State (Property)","textEng":"The final property type is Sampler State. You can use these to determine how a texture is sampled. The Filter determines how smoothing is applied to the texture: Point means no smoothing; Linear smooths between nearby pixels; and Trilinear will additionally smooth between mipmaps. The Wrap mode controls what happens if we supply UVs outside the texture bounds - Repeat copies the texture past the bounds; Clamp will round the UVs to the edge of the image; Mirror is similar to Repeat, but the texture gets reflected each time the image bound is crossed; and MirrorOnce is like Mirror, but gets clamped past the first reflection. Sampler State properties can’t be exposed to the Inspector.","textRus":"Последний тип свойства — состояние Sampler. Вы можете использовать их, чтобы определить, как сэмплируется текстура. Фильтр определяет, как сглаживание применяется к текстуре: «Точка» означает отсутствие сглаживания; Линейное сглаживание между соседними пикселями; и Trilinear дополнительно сглаживает MIP-карты. Режим Wrap управляет тем, что произойдет, если мы предоставим UV-развертки за пределами границ текстуры. Повтор копирует текстуру за пределы границ; Clamp закруглит UV-развертки к краю изображения; Зеркало похоже на Повтор, но текстура отражается каждый раз, когда граница изображения пересекается; и MirrorOnce похож на Mirror, но зажимается после первого отражения. Свойства состояния сэмплера не могут быть доступны инспектору."}},{"model":"main.shader","pk":29,"fields":{"title":"₂₉ Boolean (Keyword)","textEng":"A Boolean keyword is either true or false, so using one will result in two shader variants. Depending on the Definition, the shader acts differently: Shader Feature will strip any unused shader variants at compile time, thus removing them; Multi Compile will always build all variants; and Predefined can be used when the current Render Pipeline has already defined the keyword, so it doesn’t get redefined in the generated shader code. That might otherwise cause a shader error.","textRus":"Логическое ключевое слово имеет значение true или false, поэтому его использование приведет к двум вариантам шейдера. В зависимости от определения шейдер действует по-разному: функция шейдера удаляет все неиспользуемые варианты шейдера во время компиляции, таким образом удаляя их; Multi Compile всегда будет собирать все варианты; и Predefine можно использовать, когда текущий конвейер рендеринга уже определил ключевое слово, поэтому оно не переопределяется в сгенерированном коде шейдера. В противном случае это может привести к ошибке шейдера."}},{"model":"main.shader","pk":30,"fields":{"title":"₃₀ Enum (Keyword)","textEng":"The Enum keyword type lets us add a list of strings, which are values the enum can take, then set one of them as the default. We can choose to make our graph change behaviour based on the value of this enum, and we have the same Definition options as before.","textRus":"Тип ключевого слова Enum позволяет нам добавить список строк, которые являются значениями, которые может принимать перечисление, а затем установить одну из них по умолчанию. Мы можем выбрать поведение изменения нашего графика на основе значения этого перечисления, и у нас есть те же параметры определения, что и раньше."}},{"model":"main.shader","pk":31,"fields":{"title":"₃₁ Material Quality (Keyword)","textEng":"Unity, or a specific Render Pipeline, can add enums automatically. The Material Quality is a relatively new built-in enum keyword, which is just a built-in enum based on the quality level settings of your project. This allows you to change the behaviour of your graph based on the quality level of the game’s graphics. For example, you might choose to use a lower LOD level on certain nodes based on the material quality.","textRus":"Unity или конкретный конвейер рендеринга могут добавлять перечисления автоматически. Качество материала — это относительно новое встроенное ключевое слово перечисления, которое представляет собой просто встроенное перечисление, основанное на настройках уровня качества вашего проекта. Это позволяет вам изменять поведение вашего графика в зависимости от уровня качества игровой графики. Например, вы можете выбрать более низкий уровень детализации для определенных узлов в зависимости от качества материала."}},{"model":"main.shader","pk":32,"fields":{"title":"₃₂ Color","textEng":"The Color node comes with a rectangle which we can click to define a primitive color. As with most Color picker windows in Unity, we can switch between red-green-blue and hue-saturation-value color spaces, set the alpha, or use an existing swatch. Or we can use the color picker to select any color within the Unity window. By changing the Mode drop-down to HDR, we gain access to HDR (High Dynamic Range) colors which let us raise the intensity beyond 0, which is especially useful for emissive materials. Not every node which accepts a color input will take HDR into account, however. It has a single output, which is just the color you defined.","textRus":"Узел Цвет имеет прямоугольник, по которому мы можем щелкнуть, чтобы определить примитивный цвет. Как и в большинстве окон выбора цвета в Unity, мы можем переключаться между цветовыми пространствами красно-зелено-синего и оттенка-насыщенности, устанавливать альфу или использовать существующий образец. Или мы можем использовать палитру цветов, чтобы выбрать любой цвет в окне Unity. Изменяя раскрывающийся список «Режим» на HDR, мы получаем доступ к цветам HDR (расширенный динамический диапазон), которые позволяют нам поднимать интенсивность выше 0, что особенно полезно для излучающих материалов. Однако не каждый узел, который принимает входной цвет, будет учитывать HDR. У него есть один выход — это только тот цвет, который вы определили."}},{"model":"main.shader","pk":33,"fields":{"title":"₃₃ Float/Vector 1","textEng":"The Vector 1 node, or Float as it’s called in later versions of Shader Graph, lets us define a constant floating-point value. It takes one float input, which we can change at will, and a single output, which is the same as the input.","textRus":"Узел Vector 1, или Float, как его называют в более поздних версиях Shader Graph, позволяет нам определить постоянное значение с плавающей запятой. Он принимает один вход с плавающей запятой, который мы можем изменить по своему желанию, и один выход, который совпадает с входом."}},{"model":"main.shader","pk":34,"fields":{"title":"₃₄ Vector 2","textEng":"Vector 2 is similar to Vector 1, but we can define two floats as inputs. The output is a single Vector 2, with the first input in the X component and the second input in the Y component.","textRus":"Вектор 2 аналогичен вектору 1, но мы можем определить два числа с плавающей запятой в качестве входных данных. Выходные данные представляют собой один вектор 2 с первым входом в компоненте X и вторым входом в компоненте Y."}},{"model":"main.shader","pk":35,"fields":{"title":"₃₅ Vector 3","textEng":"Vector 3 follows the same pattern, with three inputs labelled X, Y and Z, and one output which combines the three.","textRus":"Вектор 3 следует той же схеме: три входа, помеченные X, Y и Z, и один выход, который объединяет эти три."}},{"model":"main.shader","pk":36,"fields":{"title":"₃₆ Vector 4","textEng":"And unsurprisingly, the Vector 4 node has four inputs, X, Y, Z and W, and one output which combines all four into a Vector 4. All of these nodes act like the property types.","textRus":"И неудивительно, что узел Vector 4 имеет четыре входа: X, Y, Z и W, и один выход, который объединяет все четыре в Vector 4. Все эти узлы действуют как типы свойств."}},{"model":"main.shader","pk":37,"fields":{"title":"₃₇ Integer","textEng":"The Integer node is slightly different to the Float node, in that you use it to define integers, but it also doesn’t take any inputs. We just write the integer directly inside the node. The single output, of course, is that integer.","textRus":"Узел Integer немного отличается от узла Float тем, что вы используете его для определения целых чисел, но он также не требует никаких входных данных. Мы просто пишем целое число непосредственно внутри узла. Единственным выходом, конечно же, является это целое число."}},{"model":"main.shader","pk":38,"fields":{"title":"₃₈ Boolean","textEng":"The Boolean node is like the Integer node, insofar as it doesn’t take any inputs. If the box is ticked, the output is True, and if it’s unticked, the output is False.","textRus":"Логический узел похож на узел Целочисленный, поскольку он не принимает никаких входных данных. Если флажок установлен, результат будет истинным, а если флажок снят, результат будет ложным."}},{"model":"main.shader","pk":39,"fields":{"title":"₃₉ Slider","textEng":"The Slider node is useful if you want to use a Float inside your graph, and you don’t want the user to modify the value from outside your shader, but you need some extra ease of use for testing purposes. We can define a minimum and maximum value, then, using the slider, we can output a value between those min and max values.","textRus":"Узел Slider полезен, если вы хотите использовать Float внутри вашего графика и не хотите, чтобы пользователь изменял значение снаружи вашего шейдера, но вам нужна дополнительная простота использования в целях тестирования. Мы можем определить минимальное и максимальное значение, а затем, используя ползунок, вывести значение между этими минимальными и максимальными значениями."}},{"model":"main.shader","pk":40,"fields":{"title":"₄₀ Time","textEng":"The Time node gives us access to several floats, all of which change over time. The Time output gives us the time in seconds since the scene started; Sine Time is the same as outputting Time into a sine function; Cosine Time is like using Time in a cosine function; Delta Time is the time elapsed in seconds since the previous frame; and Smooth Delta is like Delta Time, but it attempts to smooth out the values by averaging the delta over a few frames.","textRus":"Узел Time дает нам доступ к нескольким числам с плавающей запятой, которые меняются со временем. Выходные данные Time дают нам время в секундах с момента начала сцены; Sine Time — это то же самое, что выводить время в синусоидальную функцию; Косинусное время похоже на использование времени в функции косинуса; Дельта времени — это время в секундах, прошедшее с момента предыдущего кадра; и Smooth Delta похож на Delta Time, но пытается сгладить значения, усредняя дельту по нескольким кадрам."}},{"model":"main.shader","pk":41,"fields":{"title":"₄₁ Constant","textEng":"The Constant node gives you access to widely-used mathematical constants using the dropdown menu, with a single output. Those constants are pi, tau (which is equal to two times pi), phi (which is the golden ratio), e (also known as Euler’s number), and the square root of two.","textRus":"Узел «Константа» предоставляет вам доступ к широко используемым математическим константам с помощью раскрывающегося меню с одним выходом. Этими константами являются пи, тау (которое равно удвоенному числу пи), фи (золотое сечение), е (также известное как число Эйлера) и квадратный корень из двух."}},{"model":"main.shader","pk":42,"fields":{"title":"₄₂ Sample Texture 2D","textEng":"The Sample Texture 2D node is one of the nodes I use the most, in almost every shader I build. It takes in three inputs: one is the Texture to sample, the second is the UV coordinate to sample the texture at, and the third is a Sampler State which determines how to sample the texture. The node provides two extra options. When the Type is Default, the node samples the texture’s colors, and when it’s set to Normal, we can use the node to sample normal maps. The Space is only relevant when sampling in Normal mode to determine which space to output normal information for - it’s either Object or World.","textRus":"Нод «Образец текстуры 2D» — один из узлов, которые я использую чаще всего почти в каждом шейдере, который создаю. Он принимает три входных параметра: один — текстура для выборки, второй — UV-координата для выборки текстуры, а третий — состояние сэмплера, которое определяет, как производить выборку текстуры. Узел предоставляет две дополнительные опции. Если для параметра «Тип» установлено значение «По умолчанию», узел производит выборку цветов текстуры, а когда для него установлено значение «Нормальный», мы можем использовать узел для выборки карт нормалей. Пространство имеет значение только при выборке в обычном режиме, чтобы определить, для какого пространства выводить нормальную информацию — это либо Объект, либо Мир."}},{"model":"main.shader","pk":43,"fields":{"title":"₄₃ Sample Texture 2D Array","textEng":"The Sample Texture 2D Array node acts much like the Sample Texture 2D node, but now we don’t have the Type or Space options. Instead, we now have an Index input to determine which texture in the array to sample - remember from the Properties section how these arrays work.","textRus":"Узел «Образец текстуры 2D-массив» во многом аналогичен узлу «Образец текстуры 2D», но теперь у нас нет параметров «Тип» или «Пространство». Вместо этого у нас теперь есть входной индекс, позволяющий определить, какую текстуру в массиве брать в качестве образца — помните из раздела «Свойства», как работают эти массивы."}},{"model":"main.shader","pk":44,"fields":{"title":"₄₄ Sample Texture 2D LOD","textEng":"The Sample Texture 2D LOD node is the same as Sample Texture 2D, except we have an added LOD input. We can use this to set the mipmap level with which to sample the texture. Because we manually set the mipmap level, we can actually use this node in the vertex stage of a shader - I didn’t realise that before researching what these nodes do!","textRus":"Узел Sample Textura 2D LOD такой же, как и Sample Texture 2D, за исключением того, что у нас есть добавленный вход LOD. Мы можем использовать это, чтобы установить уровень MIP-карты, с помощью которого можно сэмплировать текстуру. Поскольку мы вручную устанавливаем уровень MIP-карты, мы можем фактически использовать этот узел на вершинной стадии шейдера — я не осознавал этого до исследования того, что делают эти узлы!"}},{"model":"main.shader","pk":45,"fields":{"title":"₄₅ Sample Texture 3D","textEng":"Sample Texture 3D is conceptually the same as Sample Texture 2D, except we provide a Texture 3D and the UV coordinate must be in three dimensions instead of just two. We can still supply a Sampler State, but we don’t have extra dropdown options, and for some reason we only have a single Vector 4 output without the split-channel outputs found on Sample Texture 2D.","textRus":"Образец текстуры 3D концептуально аналогичен образцу текстуры 2D, за исключением того, что мы предоставляем текстуру 3D, а UV-координата должна быть трехмерной, а не двухмерной. Мы по-прежнему можем предоставить состояние сэмплера, но у нас нет дополнительных раскрывающихся опций, и по какой-то причине у нас есть только один выход Vector 4 без выходов с разделенным каналом, которые есть в Sample Texture 2D."}},{"model":"main.shader","pk":46,"fields":{"title":"₄₆ Sample Cubemap","textEng":"The Sample Cubemap node takes in a Cubemap, a Sampler State and an LOD level, all of which we’ve seen before, and a direction, Dir, which is used instead of UVs to determine where on the cubemap we should sample. Think of a cubemap conceptually as being a textured cube, but inflated into a sphere shape. The Dir input, a vector in world space, points from the centre of the sphere outwards to a point on this sphere. The only output is the color. Since we specify the mipmap level through the LOD input, we can use this in both the fragment and vertex stages of a shader, but beware that you might encounter issues if nothing is connected to the direction input. This would be great for use on a skybox.","textRus":"Узел Sample Cubemap принимает кубическую карту, состояние Sampler и уровень LOD, все из которых мы видели раньше, а также направление Dir, которое используется вместо UV, чтобы определить, где на кубической карте нам следует производить выборку. Концептуально можно представить кубическую карту как текстурированный куб, но раздутый до сферы. Вход Dir, вектор в мировом пространстве, указывает из центра сферы наружу на точку на этой сфере. Единственный выход — это цвет. Поскольку мы указываем уровень MIP-карты через вход LOD, мы можем использовать его как на этапе фрагмента, так и на этапе вершины шейдера, но будьте осторожны, вы можете столкнуться с проблемами, если к входу направления ничего не подключено. Это было бы здорово для использования в скайбоксе."}},{"model":"main.shader","pk":47,"fields":{"title":"₄₇ Sample Reflected Cubemap","textEng":"The Sample Reflected Cubemap node is like the Sample Cubemap node, except we have an extra Normal input, and both that and the view direction need to be in object space. Conceptually, this node acts as if we are viewing an object in the world and reflecting the view direction vector off the object using its surface normal vector, then using the reflected vector to sample the cubemap. In contrast to Sample Cubemap, the Sample Reflected Cubemap node is great for adding reflected light from a skybox to an object in the scene.","textRus":"Узел Sample Reflected Cubemap аналогичен узлу Sample Cubemap, за исключением того, что у нас есть дополнительный вход Normal, и и он, и направление обзора должны находиться в пространстве объектов. Концептуально этот узел действует так, как если бы мы просматривали объект в мире и отражали вектор направления обзора от объекта, используя вектор нормали к его поверхности, а затем использовали отраженный вектор для выборки кубической карты. В отличие от Sample Cubemap, нод Sample Reflected Cubemap отлично подходит для добавления отраженного света из скайбокса к объекту в сцене."}},{"model":"main.shader","pk":48,"fields":{"title":"₄₈ Sample Virtual Texture","textEng":"The Sample Virtual Texture node has two inputs by default: the UVs with which to sample the texture, and a Virtual Texture slot. Once you connect a virtual texture, the number of outputs from the node changes to match the number of layers on the Virtual Texture object. We can use any of those outputs we wish.","textRus":"Узел Sample Virtual Texture по умолчанию имеет два входа: UV, с помощью которых можно сэмплировать текстуру, и слот Virtual Texture. После подключения виртуальной текстуры количество выходных сигналов узла изменяется в соответствии с количеством слоев объекта виртуальной текстуры. Мы можем использовать любой из этих результатов, какой пожелаем."}},{"model":"main.shader","pk":49,"fields":{"title":"₄₉ Sampler State","textEng":"The Sampler State node works just like a Sampler State property: it lets us define the Filter mode and Wrap mode to sample a texture with. We can attach one to most of the texture-sampling nodes we’ve seen so far.","textRus":"Узел Sampler State работает так же, как свойство Sampler State: он позволяет нам определить режим фильтра и режим Wrap для выборки текстуры. Мы можем прикрепить его к большинству узлов выборки текстур, которые мы видели до сих пор."}},{"model":"main.shader","pk":50,"fields":{"title":"₅₀ Texture 2D Asset","textEng":"The Texture 2D Asset node lets us find any Texture 2D defined in the Assets folder and use it in our graph. This is useful if this shader always uses the same texture, no matter which material instance is used, and we don’t want to use a property.","textRus":"Узел «Ресурс текстуры 2D» позволяет нам найти любую текстуру 2D, определенную в папке «Активы», и использовать ее в нашем графике. Это полезно, если этот шейдер всегда использует одну и ту же текстуру, независимо от того, какой экземпляр материала используется, и мы не хотим использовать свойство."}},{"model":"main.shader","pk":51,"fields":{"title":"₅₁ Texture 2D Array Asset","textEng":"The Texture 2D Array Asset node is the same as Texture 2D Asset, except we grab hold of a Texture 2D Array instead.","textRus":"Узел 2D-массива текстуры аналогичен 2D-ресурсу текстуры, за исключением того, что вместо этого мы используем 2D-массив текстуры."}},{"model":"main.shader","pk":52,"fields":{"title":"₅₂ Texture 3D Asset","textEng":"As you may expect, the Texture 3D Asset node can be used to access a Texture 3D asset within your graph without using a property.","textRus":"Как и следовало ожидать, узел «Ресурс текстуры 3D» можно использовать для доступа к активу «Текстура 3D» на вашем графике без использования свойства."}},{"model":"main.shader","pk":53,"fields":{"title":"₅₃ Cubemap Asset","textEng":"To finish off the set, we can use a Cubemap Asset node to access a cubemap texture in the graph.","textRus":"Чтобы завершить набор, мы можем использовать узел Cubemap Asset для доступа к текстуре кубической карты в графе."}},{"model":"main.shader","pk":54,"fields":{"title":"₅₄ Texel Size","textEng":"The Texel Size node takes in a Texture 2D as input and outputs the width and height of the texture in pixels. “Texel” in this context is short for “texture element”, and can be thought of as analogous to “pixel”, which itself is short for “picture element”. The more you know!","textRus":"Узел Texel Size принимает на вход текстуру 2D и выводит ширину и высоту текстуры в пикселях. «Тексель» в этом контексте является сокращением от «элемент текстуры» и может рассматриваться как аналог слова «пиксель», которое само по себе является сокращением от «элемент изображения». Чем больше ты знаешь!"}},{"model":"main.shader","pk":55,"fields":{"title":"₅₅ Screen","textEng":"The Screen node gets the width and the height of the screen in pixels and returns those as its two outputs.","textRus":"Узел Screen получает ширину и высоту экрана в пикселях и возвращает их в качестве двух выходных данных."}},{"model":"main.shader","pk":56,"fields":{"title":"₅₆ Scene Color","textEng":"The Scene Color node lets us access the framebuffer before rendering has finished this frame, and it can only be used in the fragment shader stage. In URP, we can only use this on Transparent materials and it will only show opaque objects, and the behaviour of the node can change between render pipelines. The UV input takes in the screen position you’d like to sample, and by default, it uses the same screen position UV as the pixel being rendered. I’ll talk about the other options on the drop-down when we get to the Screen Position node. The output is the color sampled at this position.","textRus":"Узел «Цвет сцены» позволяет нам получить доступ к кадровому буферу до завершения рендеринга этого кадра, и его можно использовать только на этапе фрагментного шейдера. В URP мы можем использовать это только для прозрачных материалов, и оно будет отображать только непрозрачные объекты, а поведение узла может меняться между конвейерами рендеринга. Ввод UV принимает положение экрана, которое вы хотите получить, и по умолчанию использует ту же позицию UV экрана, что и визуализируемый пиксель. Я расскажу о других опциях раскрывающегося списка, когда мы доберемся до узла «Положение экрана». Результатом является цвет, выбранный в этой позиции."}},{"model":"main.shader","pk":57,"fields":{"title":"₅₇ Scene Depth","textEng":"Similar to the Scene Color node, the Scene Depth node can be used to access the depth buffer, which is a measure of how far a rendered pixel is away from the camera. Again, in URP, this can only be used by transparent materials. The input it expects is a UV coordinate.","textRus":"Подобно узлу Цвет сцены, узел Глубина сцены можно использовать для доступа к буферу глубины, который является мерой того, насколько далеко отрисованный пиксель находится от камеры. Опять же, в URP это можно использовать только с прозрачными материалами. Ожидаемые входные данные — это UV-координата."}},{"model":"main.shader","pk":58,"fields":{"title":"₅₈ Camera","textEng":"The Camera node is only supported by the Universal Render Pipeline. It gives you access to a range of properties related to the camera that’s currently being used for rendering, such as the Position in world space, the forward Direction vector, and whether the camera is Orthographic – if so, 1 is output, otherwise 0 is output. We have access to the Near Plane and Far Plane, which are two clipping planes, represented as floats, as well as the Z Buffer Sign, which returns 1 or -1 depending on whether we are using the standard or reversed depth buffer. You might want to use this node if you are making depth-based effects, for example using the Scene Depth node. Finally, the Width and Height outputs get you the width and height of the screen in world space units, but only if your camera is orthographic.","textRus":"Узел «Камера» поддерживается только универсальным конвейером рендеринга. Он дает вам доступ к ряду свойств, связанных с камерой, которая в данный момент используется для рендеринга, таких как положение в мировом пространстве, вектор прямого направления и то, является ли камера ортогональной — если да, выводится 1, в противном случае — 0. выход. У нас есть доступ к ближней плоскости и дальней плоскости, которые представляют собой две плоскости отсечения, представленные в виде чисел с плавающей запятой, а также знак Z-буфера, который возвращает 1 или -1 в зависимости от того, используем ли мы стандартный или обратный буфер глубины. Возможно, вам захочется использовать этот узел, если вы создаете эффекты на основе глубины, например, используя узел «Глубина сцены». Наконец, выходные данные «Ширина» и «Высота» дают вам ширину и высоту экрана в единицах мирового пространства, но только если ваша камера ортогональная."}},{"model":"main.shader","pk":59,"fields":{"title":"₅₉ Fog","textEng":"The Fog node is also not supported by HDRP. It returns information about the fog you’ve defined in the Lighting tab’s Environment Settings. We need to pass in the Position in object space, and we get the Color of the fog and its Density at that position. We can use the node in the vertex and fragment stages of your shader.","textRus":"Узел Fog также не поддерживается HDRP. Он возвращает информацию о тумане, который вы определили в настройках среды на вкладке «Освещение». Нам нужно передать позицию в пространстве объектов, и мы получим цвет тумана и его плотность в этой позиции. Мы можем использовать узел на стадиях вершин и фрагментов вашего шейдера."}},{"model":"main.shader","pk":60,"fields":{"title":"₆₀ Object","textEng":"The Object node returns two outputs: the Position and Scale of your object in world space, as Vector 3s.","textRus":"Узел «Объект» возвращает два результата: положение и масштаб вашего объекта в мировом пространстве в виде вектора 3."}},{"model":"main.shader","pk":61,"fields":{"title":"₆₁ Ambient","textEng":"The Ambient node returns three color values, each of which is a different type of ambient light from the scene, but it is only supported by URP. These values depend on the values in the Environment Lighting section of the Lighting tab. The node’s Equator and Ground output always return the Environment Lighting Equator and Ground values, regardless of which Source type is picked, even though they only exist when Gradient is picked. The node’s Color/Sky outputs the Sky color when the mode is set to Gradient, or Ambient Color when the Source is set to Color.","textRus":"Узел Ambient возвращает три значения цвета, каждое из которых представляет собой отдельный тип окружающего света сцены, но поддерживается только URP. Эти значения зависят от значений в разделе «Освещение среды» на вкладке «Освещение». Выходные данные узла «Экватор» и «Земля» всегда возвращают значения «Экватор освещения окружающей среды» и «Земля», независимо от того, какой тип источника выбран, даже если они существуют только при выборе «Градиента». Нод «Цвет/Небо» выводит цвет неба, если для режима установлен «Градиент», или «Цвет окружающей среды», если для параметра «Источник» установлено значение «Цвет»."}},{"model":"main.shader","pk":62,"fields":{"title":"₆₂ Reflection Probe","textEng":"The Reflection Probe node is only defined for the Universal Render Pipeline. We can use this to access the nearest reflection probe to the object by passing in the surface normal of the mesh and the view direction of the camera – if you remember the way I described the Sample Reflected Cubemap node, it works in a similar way. We can also specify the LOD to sample at lower qualities if we want blurry reflections. The single output, just named Out, is the color of the reflection from the reflection probe as a Vector 3.","textRus":"Узел Reflection Probe определен только для универсального конвейера рендеринга. Мы можем использовать это для доступа к ближайшему датчику отражения к объекту, передав нормаль к поверхности сетки и направление обзора камеры — если вы помните, как я описывал нод Sample Reflected Cubemap, он работает аналогичным образом. Мы также можем указать LOD для выборки с более низким качеством, если нам нужны размытые отражения. Единственный выходной сигнал, названный Out, представляет собой цвет отражения от отражающего зонда в виде вектора 3."}},{"model":"main.shader","pk":63,"fields":{"title":"₆₃ Baked GI","textEng":"The Baked GI node can be used to retrieve lighting created by Unity’s baked lightmapper. We need to provide a Position and Normal vector in world space so that Unity knows where to access the lightmap information, and then we need to provide a set of UVs so Unity knows how to apply the lightmap to the mesh. Lightmap UVs come in two forms: the Static UVs, which occupy the UV1 slot usually, are for mapping lights which stay stationary for the entire game, and Dynamic UVs, which are found in the UV2 slot by default, are used for lights that might turn on or off, or even move during runtime.","textRus":"Узел Baked GI можно использовать для получения освещения, созданного запеченным картографом освещения Unity. Нам нужно предоставить вектор положения и нормали в мировом пространстве, чтобы Unity знала, где получить доступ к информации о карте освещения, а затем нам нужно предоставить набор UV, чтобы Unity знала, как применить карту освещения к сетке. UV-карты освещения бывают двух форм: статические UV-объекты, которые обычно занимают слот UV1, предназначены для отображения источников света, которые остаются неподвижными на протяжении всей игры, а динамические UV-объекты, которые по умолчанию находятся в слоте UV2, используются для источников света, которые могут включать или выключать или даже перемещать во время выполнения."}},{"model":"main.shader","pk":64,"fields":{"title":"₆₄ Matrix 2x2","textEng":"Matrices can be used for operations such as multiplying vectors. I won’t go into much detail about matrices here, because it’s a very dense topic – but all you need to know here is that we can define our own matrix constants inside the shader. The Matrix 2x2 node lets us define a square matrix with two rows and two columns.","textRus":"Матрицы можно использовать для таких операций, как умножение векторов. Я не буду здесь вдаваться в подробности о матрицах, потому что это очень сложная тема, но все, что вам здесь нужно знать, это то, что мы можем определять наши собственные матричные константы внутри шейдера. Узел Матрица 2x2 позволяет нам определить квадратную матрицу с двумя строками и двумя столбцами."}},{"model":"main.shader","pk":65,"fields":{"title":"₆₅ Matrix 3x3","textEng":"Similarly, the Matrix 3x3 node lets us define matrices with three rows and three columns.","textRus":"Аналогичным образом узел Матрица 3x3 позволяет нам определять матрицы с тремя строками и тремя столбцами."}},{"model":"main.shader","pk":66,"fields":{"title":"₆₆ Matrix 4x4","textEng":"The largest type of matrix supported in shaders is the 4x4 square matrix, which we can create with a Matrix 4x4 node.","textRus":"Самый большой тип матрицы, поддерживаемый в шейдерах, — это квадратная матрица 4x4, которую мы можем создать с помощью узла Matrix 4x4."}},{"model":"main.shader","pk":67,"fields":{"title":"₆₇ Transformation Matrix","textEng":"Matrices are super useful for transformations, and Unity defines many of matrices involved in transforming from one space to another. Sometimes, these matrices are used in the background, but we can access them using the Transformation Matrix node.","textRus":"Матрицы очень полезны для преобразований, и Unity определяет множество матриц, участвующих в преобразовании из одного пространства в другое. Иногда эти матрицы используются в фоновом режиме, но мы можем получить к ним доступ с помощью узла Матрица преобразования."}},{"model":"main.shader","pk":68,"fields":{"title":"₆₈ Position","textEng":"The Position node will grab the position of the vertex or fragment, whichever shader stage you’re using. Only one Vector 3 output exists, and that will be the position, but there is a drop-down that lets us pick which space the position will be. We’ve talked about the Object, View and Tangent spaces previously, and Absolute World is the same world space of the vertex or fragment as we’ve described world space before. The World option differs by render pipeline and it uses the pipeline’s default world space. In URP, it’s the same as Absolute World, but HDRP uses camera-relative rendering by default, so the world space becomes relative to the camera position.","textRus":"Узел «Позиция» будет фиксировать положение вершины или фрагмента, независимо от того, какой этап шейдера вы используете. Существует только один выход Vector 3, и это будет позиция, но есть раскрывающийся список, который позволяет нам выбрать, в каком пространстве будет позиция. Ранее мы говорили о пространствах объектов, видов и касательных, а Абсолютный мир — это то же самое мировое пространство вершины или фрагмента, которое мы описывали ранее. Параметр «Мир» зависит от конвейера рендеринга и использует мировое пространство конвейера по умолчанию. В URP это то же самое, что и в Absolute World, но HDRP по умолчанию использует рендеринг относительно камеры, поэтому мировое пространство становится относительным к положению камеры."}},{"model":"main.shader","pk":69,"fields":{"title":"₆₉ Screen Position","textEng":"The Screen Position node gets the position of the pixel on the screen, with a single Vector 4 output representing the screen position. The Mode influences exactly which screen position is used. By Default, we use the clip space after dividing by the W component – this is called the perspective divide. Raw mode, however, returns the screen position before the perspective divide, which is useful if you want to perform a projection of your own. Center will return the screen position such that (0, 0) is now in the centre of the screen instead of the bottom-left corner, and Tiled also puts (0, 0) in the centre of the screen, but takes only the fractional part of the position – the number past the decimal point - so you end up with tiles.","textRus":"Узел «Положение экрана» получает положение пикселя на экране, а один выходной сигнал Vector 4 представляет положение экрана. Режим влияет на то, какое именно положение экрана используется. По умолчанию мы используем пространство отсечения после деления на компонент W — это называется разделением перспективы. Однако режим Raw возвращает положение экрана до разделения перспективы, что полезно, если вы хотите выполнить собственную проекцию. Center вернет такое положение экрана, что (0, 0) теперь находится в центре экрана, а не в левом нижнем углу, а Tiled также помещает (0, 0) в центр экрана, но принимает только дробную часть. часть позиции – число после десятичной точки – так что в итоге вы получите плитки."}},{"model":"main.shader","pk":70,"fields":{"title":"₇₀ UV","textEng":"The UV node can be used to get the UV coordinates of a vertex or fragment. Unity allows you to bake more than one texture coordinate into your mesh’s data, so we can use the Channel drop down to retrieve one of four sets of UV coordinates. Most meshes will only use UV0, but you can use the other channels to hide more data.","textRus":"Узел UV можно использовать для получения UV-координат вершины или фрагмента. Unity позволяет вам запекать более одной текстурной координаты в данные вашей сетки, поэтому мы можем использовать раскрывающийся список «Канал» для получения одного из четырех наборов UV-координат. Большинство сеток используют только UV0, но вы можете использовать другие каналы, чтобы скрыть больше данных."}},{"model":"main.shader","pk":71,"fields":{"title":"₇₁ Vertex Color","textEng":"The Vertex Color node can be used to get the color attached to the mesh’s vertex data. Despite the name, this can be used in both the vertex and fragment shader stages – but you’ll have to set up your mesh beforehand to have vertex color data baked into it, which you can do inside your modelling program or via scripting. In the fragment stage, the colors between vertices get blended together.","textRus":"Узел Vertex Color можно использовать для получения цвета, присвоенного данным вершин сетки. Несмотря на название, его можно использовать как на этапах вершинного, так и на фрагментном шейдере, но вам придется заранее настроить сетку, чтобы в нее были встроены данные цвета вершин, что вы можете сделать в своей программе моделирования или с помощью сценариев. На этапе фрагмента цвета между вершинами смешиваются."}},{"model":"main.shader","pk":72,"fields":{"title":"₇₂ View Direction","textEng":"The View Direction node gets the vector between the vertex or fragment and the camera. The drop-down lets us change the Space between World, View, Object or Tangent – we’ve talked about all of those before.","textRus":"Узел View Direction получает вектор между вершиной или фрагментом и камерой. Раскрывающийся список позволяет нам изменить пространство между миром, видом, объектом или касательной — обо всем этом мы говорили раньше."}},{"model":"main.shader","pk":73,"fields":{"title":"₇₃ Normal Vector","textEng":"The Normal Vector node gets the vector perpendicular to the surface pointing outwards away from the surface. Like View Direction, it gives us the option to pick different spaces and only outputs the single vector.","textRus":"Узел «Вектор нормали» получает вектор, перпендикулярный поверхности, направленный наружу от поверхности. Как и «Направление просмотра», он дает нам возможность выбирать разные пространства и выводит только один вектор."}},{"model":"main.shader","pk":74,"fields":{"title":"₇₄ Tangent Vector","textEng":"The Tangent Vector node gets a vector that lies on the surface. This vector is perpendicular to the Normal Vector, and like the Normal Vector node, we get four space options.","textRus":"Узел Tangent Vector получает вектор, лежащий на поверхности. Этот вектор перпендикулярен вектору нормали, и, как и узел вектора нормали, мы получаем четыре варианта пространства."}},{"model":"main.shader","pk":75,"fields":{"title":"₇₅ Bitangent Vector","textEng":"The Bitangent Vector node gets another vector that is parallel with the surface. If you take the cross product between the Tangent Vector and the Normal Vector, you will get the same result as the Bitangent Vector node. We’ll talk about the cross product shortly.","textRus":"Узел Бикасательный вектор получает еще один вектор, параллельный поверхности. Если вы возьмете векторное произведение касательного вектора и вектора нормали, вы получите тот же результат, что и узел бикасательного вектора. Вскоре мы поговорим о перекрестном произведении."}},{"model":"main.shader","pk":76,"fields":{"title":"₇₆ Gradient","textEng":"The Gradient node lets us define a gradient of our own to use inside the shader. By clicking on the rectangle on the node, we get access to the Gradient Editor window, which is the same as the one used elsewhere in the Unity Editor. We can modify the top row of handles to change the alpha and use the bottom row to tweak colors. The only output is the gradient itself.","textRus":"Узел Градиент позволяет нам определить собственный градиент для использования внутри шейдера. Нажав на прямоугольник на узле, мы получаем доступ к окну редактора градиентов, которое такое же, как и в других местах редактора Unity. Мы можем изменить верхний ряд маркеров, чтобы изменить альфу, и использовать нижний ряд для настройки цветов. Единственным результатом является сам градиент."}},{"model":"main.shader","pk":77,"fields":{"title":"₇₇ Sample Gradient","textEng":"Which brings us to the Sample Gradient node, which is the only node that currently takes a Gradient as an input. It also uses an input called Time, which is a float between 0 and 1 which determines which position to sample the gradient at. The output is the color sampled at that point.","textRus":"Это подводит нас к узлу Выборочный градиент, который в настоящее время является единственным узлом, который в настоящее время принимает градиент в качестве входных данных. Он также использует входные данные под названием Time, которые представляют собой число с плавающей запятой между 0 и 1, которое определяет, в какой позиции производить выборку градиента. Результатом является цвет, выбранный в этот момент."}},{"model":"main.shader","pk":78,"fields":{"title":"₇₈ Blackbody","textEng":"The Blackbody node is interesting – it takes in a temperature in Kelvin as input and outputs the color of a blackbody at that temperature. Don’t know what a blackbody is? Then you’re probably not a physicist. A blackbody is an idealised completely opaque, non-reflective object, so the thermal radiation emitted is a function of its temperature. They start off black, and cycle through red, orange, yellow and finally white as they increase in temperature.","textRus":"Узел «Черное тело» интересен — он принимает температуру в Кельвинах в качестве входных данных и выводит цвет черного тела при этой температуре. Не знаете, что такое черное тело? Тогда вы, вероятно, не физик. Черное тело — это идеализированный, полностью непрозрачный, неотражающий объект, поэтому испускаемое тепловое излучение является функцией его температуры. Они начинаются с черного цвета, а по мере повышения температуры меняют красный, оранжевый, желтый и, наконец, белый цвет."}},{"model":"main.shader","pk":79,"fields":{"title":"₇₉ Dielectric Specular","textEng":"The Dielectric Specular node requires a bit of explanation. Dielectric materials are electrical insulators, so in this context, think of them as non-metals. This node outputs the strength of specular highlights on certain types of material based on its refractive index. We can switch the Material type, and values are defined for rusted metal, water, ice and glass. There’s an option for common materials – which you would use for common materials like fabric, plastic or maybe wood – which gives us a range to pick between, and a Custom option, where the output is based on the index of refraction. If using the custom option, look up the refractive index of the material you want online. For example, the index of refraction for ice is 1.3098, which gives the same strength as the preset for ice.","textRus":"Узел Dielectric Specular требует небольшого пояснения. Диэлектрические материалы являются электрическими изоляторами, поэтому в этом контексте считайте их неметаллами. Этот узел выводит силу зеркальных бликов на определенных типах материала на основе его показателя преломления. Мы можем переключить тип материала, а значения определены для ржавого металла, воды, льда и стекла. Существует опция для обычных материалов, которую вы можете использовать для обычных материалов, таких как ткань, пластик или, возможно, дерево, что дает нам диапазон выбора, а также опция «Пользовательский», где результат основан на показателе преломления. При использовании пользовательской опции найдите в Интернете показатель преломления нужного материала. Например, показатель преломления для льда равен 1,3098, что дает ту же силу, что и заданная для льда."}},{"model":"main.shader","pk":80,"fields":{"title":"₈₀ Metal Reflectance","textEng":"The Metal Reflectance is similar to Dielectric Specular, but now it outputs the color of the specular highlights on certain metals. The key difference is that the specular highlights for metals are colored rather than greyscale, as they are for dielectric materials. Unity provides values for iron, silver, aluminium, gold, copper, chromium, nickel, titanium, cobalt and platinum, with no further options for custom metals.","textRus":"Отражение металла похоже на Dielectric Specular, но теперь оно выводит цвет зеркальных бликов на определенных металлах. Ключевое отличие состоит в том, что зеркальные блики для металлов окрашены в цвет, а не в оттенки серого, как для диэлектрических материалов. Unity предоставляет значения для железа, серебра, алюминия, золота, меди, хрома, никеля, титана, кобальта и платины без дополнительных возможностей для пользовательских металлов."}},{"model":"main.shader","pk":81,"fields":{"title":"₈₁ Diffusion Profile","textEng":"Like all nodes under the High Definition Render Pipeline group, the Diffusion Profile node is of course not available on Universal Render Pipeline. This node is used to sample a Diffusion Profile asset, which is exclusive to HDRP and contains settings related to subsurface scattering. The output is a float which is an ID used to pick the correct diffusion profile. The ID is used for the corresponding block node in HDRP (which I haven’t covered because HDRP ships with like, a million extra block nodes).","textRus":"Как и все узлы в группе конвейера рендеринга высокого разрешения, узел профиля диффузии, конечно же, недоступен в универсальном конвейере рендеринга. Этот узел используется для выборки ресурса профиля диффузии, который является эксклюзивным для HDRP и содержит настройки, связанные с подповерхностным рассеянием. Выходные данные представляют собой число с плавающей запятой, которое представляет собой идентификатор, используемый для выбора правильного профиля диффузии. Идентификатор используется для соответствующего узла блока в HDRP (который я не рассмотрел, поскольку HDRP поставляется примерно с миллионом дополнительных узлов блока)."}},{"model":"main.shader","pk":82,"fields":{"title":"₈₂ Exposure","textEng":"The Exposure node is an HDRP-exclusive node that you can use to get the camera’s exposure level on the current or previous frame. The only output from the node is a Vector3 representing that exposure level. There are four exposure types you can pick from the Type dropdown. The two labelled Current get exposure from this frame, while the Previous ones get the exposure from last frame. The two called Inverse return the inverse of the exposure on a given frame.","textRus":"Узел «Экспозиция» — это эксклюзивный узел HDRP, который вы можете использовать для получения уровня экспозиции камеры в текущем или предыдущем кадре. Единственным выходом узла является Vector3, представляющий этот уровень воздействия. В раскрывающемся списке «Тип» можно выбрать четыре типа воздействия. Два, помеченные как «Текущий», получают экспозицию из этого кадра, а «Предыдущие» получают экспозицию из последнего кадра. Два, называемые «Инверсия», возвращают инверсию экспозиции в данном кадре."}},{"model":"main.shader","pk":83,"fields":{"title":"₈₃ HD Scene Color","textEng":"The HD Scene Color is the HDRP-exclusive counterpart of the regular Scene Color node. Unlike Scene Color, HD Scene Color has an extra LOD input which lets us pick the mipmap level we use to access the color buffer – this node always uses trilinear filtering to smooth between mipmaps. We also have an Exposure checkbox to choose whether to apply exposure – it’s disabled by default to avoid double exposure. The only output from the node is the color that gets sampled.","textRus":"Цвет сцены HD — это эксклюзивный HDRP аналог обычного узла цвета сцены. В отличие от цвета сцены, цвет сцены HD имеет дополнительный вход LOD, который позволяет нам выбирать уровень MIP-карты, который мы используем для доступа к буферу цвета — этот узел всегда использует трилинейную фильтрацию для сглаживания между MIP-картами. У нас также есть флажок «Экспозиция», позволяющий выбрать, применять ли экспозицию — по умолчанию он отключен, чтобы избежать двойной экспозиции. Единственным выходным сигналом узла является цвет, который берется в качестве образца."}},{"model":"main.shader","pk":84,"fields":{"title":"₈₄ Compute Deformation","textEng":"The Compute Deformation node is exclusive to the DOTS Hybrid Renderer and can be used to send deformed vertex data to this shader. You’ll need some knowledge of DOTS to get this working – and I certainly don’t. The three outputs are deformed Vertex Position, Normal and Tangent, which usually get output to the vertex stage’s three pins.","textRus":"Узел Compute Deformation является эксклюзивным для DOTS Hybrid Renderer и может использоваться для отправки данных деформированных вершин в этот шейдер. Чтобы это заработало, вам потребуются некоторые знания DOTS – а мне это точно не нужно. Три выхода — это деформированное положение вершины, нормальное и касательное, которые обычно выводятся на три контакта вершинного этапа."}},{"model":"main.shader","pk":85,"fields":{"title":"₈₅ Linear Blend Skinning","textEng":"The Linear Blend Skinning node is also exclusive to the DOTS Hybrid Renderer. We can use the three inputs for Position, Normal and Tangent vectors and this node will apply vertex skinning to each and give us the corresponding results as three output vectors.","textRus":"Узел Linear Blend Skinning также является эксклюзивным для DOTS Hybrid Renderer. Мы можем использовать три входа для векторов положения, нормали и касательной, и этот узел будет применять скин вершин к каждому и давать нам соответствующие результаты в виде трех выходных векторов."}},{"model":"main.shader","pk":86,"fields":{"title":"₈₆ Split","textEng":"The Split node takes in a Vector 4 as input and output the four channels of the vector as separate floats. If you supplied a vector with fewer than 4 components, then the ‘extra’ outputs will be zero.","textRus":"Узел разделения принимает вектор 4 в качестве входных данных и выводит четыре канала вектора как отдельные числа с плавающей запятой. Если вы предоставили вектор с менее чем 4 компонентами, то «лишние» выходные данные будут равны нулю."}},{"model":"main.shader","pk":87,"fields":{"title":"₈₇ Swizzle","textEng":"Swizzling is when you take the components of a vector and output them in a different order. The Swizzle node takes in a vector of up to four elements as input, and provides four options on the node to determine how to swizzle the input. This node always outputs a Vector 4, and each option lets us choose an input channel to use for the corresponding output. For example, changing the “Green Out” dropdown to Blue means the second output component takes the third input component.","textRus":"Swizzling — это когда вы берете компоненты вектора и выводите их в другом порядке. Узел Swizzle принимает в качестве входных данных вектор, содержащий до четырех элементов, и предоставляет на узле четыре параметра, позволяющие определить, как переворачивать входные данные. Этот узел всегда выводит вектор 4, и каждая опция позволяет нам выбрать входной канал, который будет использоваться для соответствующего вывода. Например, изменение раскрывающегося списка «Зеленый выход» на «Синий» означает, что второй выходной компонент принимает третий входной компонент."}},{"model":"main.shader","pk":88,"fields":{"title":"₈₈ Flip","textEng":"The Flip node takes a vector of up to four elements as input, and for each input component, the node provides a checkbox to decide whether to flip that input. Flipping means that positive values become negative, and vice versa. The output vector has as many components as the input.","textRus":"Узел Flip принимает в качестве входных данных вектор, содержащий до четырех элементов, и для каждого входного компонента узел предоставляет флажок, позволяющий решить, следует ли переворачивать эти входные данные. Переворот означает, что положительные значения становятся отрицательными, и наоборот. Выходной вектор имеет столько же компонентов, сколько и входной."}},{"model":"main.shader","pk":89,"fields":{"title":"₈₉ Combine","textEng":"The Combine node lets us feed up to four values into the R, G, B and A inputs and the node will combine those individual elements into vectors. The node provides three outputs with four, three and two components respectively, depending on the size of the vector you want to create.","textRus":"Узел «Объединить» позволяет нам подавать до четырех значений на входы R, G, B и A, и узел объединит эти отдельные элементы в векторы. Узел предоставляет три выхода с четырьмя, тремя и двумя компонентами соответственно, в зависимости от размера вектора, который вы хотите создать."}},{"model":"main.shader","pk":90,"fields":{"title":"₉₀ Tiling And Offset","textEng":"Tiling And Offset is another node you’ll see me use often. As the name suggests, you can use this node to tile and offset your UVs, which is especially helpful for texturing – the Tiling input is a Vector 2 which controls how many times the texture is copied across an object, and the Offset Vector 2 input can be used to scroll the texture in whichever direction you want. The other input is the set of UVs which the tiling and offset is applied to. The output is a new set of UVs after the tiling and offset have been applied.","textRus":"Tiling And Offset — еще один узел, который я часто использую. Как следует из названия, вы можете использовать этот узел для мозаики и смещения ваших UV-разверток, что особенно полезно для текстурирования: вход «Мозаика» — это вектор 2, который контролирует, сколько раз текстура копируется по объекту, а вход «Вектор смещения 2» можно использовать для прокрутки текстуры в любом направлении. Другой вход — это набор UV, к которым применяется мозаика и смещение. Результатом является новый набор UV после применения тайлинга и смещения."}},{"model":"main.shader","pk":91,"fields":{"title":"₉₁ Rotate","textEng":"The Rotate node takes in a UV as input and will rotate around the Centre point, which is another input Vector 2, by the rotation amount, which is a float input. This node also has a Unit dropdown, which determines whether the rotation is applied in radians or degrees. The single output is a new set of UV coordinates after the rotation has been applied.","textRus":"Нод Rotate принимает UV в качестве входных данных и будет вращаться вокруг центральной точки, которая является еще одним входным вектором 2, на величину поворота, которая является входным значением с плавающей запятой. Этот узел также имеет раскрывающийся список «Единицы измерения», который определяет, будет ли вращение применяться в радианах или градусах. Единственный результат — это новый набор UV-координат после применения вращения."}},{"model":"main.shader","pk":92,"fields":{"title":"₉₂ Spherize","textEng":"The Spherize node distorts the UVs as if they’re being applied to a sphere instead of a flat surface – the Unity documentation describes it like a fisheye lens. The UV input gives us the base UVs before the transformation, and like Rotate, the Centre gives us the origin point of the effect. The Strength determines how strongly the effect is applied, and the Offset is used to scroll the UVs before the transformation has been applied. The only output is the UVs after being spherized.","textRus":"Нод Spherize искажает UV-развертки, как если бы они применялись к сфере, а не к плоской поверхности — в документации Unity он описан как линза «рыбий глаз». Ввод UV дает нам базовые UV-развертки перед преобразованием, и, как и в случае с поворотом, центр дает нам исходную точку эффекта. Сила определяет, насколько сильно применяется эффект, а смещение используется для прокрутки UV до применения преобразования. Единственный результат — это UV-изображения после сферизации."}},{"model":"main.shader","pk":93,"fields":{"title":"₉₃ Twirl","textEng":"The Twirl node has the same four inputs as Spherize, except now the transformation is that the UVs spiral from the outer edge. The single output is the new set of UVs after the twirling.","textRus":"Нод Twirl имеет те же четыре входа, что и Spherize, за исключением того, что теперь преобразование заключается в том, что UV-развертки идут по спирали от внешнего края. Единственный результат — это новый набор UV после вращения."}},{"model":"main.shader","pk":94,"fields":{"title":"₉₄ Radial Shear","textEng":"The Radial Shear node also takes those same four inputs as Twirl and Spherize, but now the transformation is a wave effect from whatever the centre point is. The output is a new set of UVs after the transformation is applied.","textRus":"Узел «Радиальный сдвиг» также принимает те же четыре входных сигнала, что и «Закручивание» и «Сферизация», но теперь преобразование представляет собой волновой эффект от любой центральной точки. Результатом является новый набор UV после применения преобразования."}},{"model":"main.shader","pk":95,"fields":{"title":"₉₅ Triplanar","textEng":"The Triplanar node is a bit more complicated to explain. The idea is that we sample the texture three times along the world-space X, Y and Z axes, which ends up with three mappings that look great applied from those three directions. For that, we supply a Texture and a Sampler as input. Then, one of those mappings is planar-projected onto the mesh based on the normal vector on the surface. The one that results in the least amount of distortion is picked, with some amount of blending.","textRus":"Узел Трипланар объяснить немного сложнее. Идея состоит в том, что мы трижды сэмплируем текстуру по осям X, Y и Z мирового пространства, в результате чего получаем три отображения, которые отлично смотрятся при применении с этих трех направлений. Для этого мы предоставляем текстуру и сэмплер в качестве входных данных. Затем одно из этих отображений плоско проецируется на сетку на основе вектора нормали к поверхности. Выбирается тот, который приводит к наименьшему количеству искажений, с некоторым смешиванием."}},{"model":"main.shader","pk":96,"fields":{"title":"₉₆ Polar Coordinates","textEng":"The Polar Coordinates node is used to transform a set of UVs from a Cartesian coordinate system, which is the coordinate system you’re likely most familiar with, to a Polar coordinate system, where each point is described by a distance and an angle away from some centre point. The UVs and Centre point are both inputs, and we can set how much to scale the angle and length using the Radial Scale and Length Scale float inputs respectively. The output is a new set of UVs in this polar coordinate system.","textRus":"Узел «Полярные координаты» используется для преобразования набора UV-разверток из декартовой системы координат, с которой вы, вероятно, наиболее знакомы, в полярную систему координат, где каждая точка описывается расстоянием и углом от некая центральная точка. Точка UV и центральная точка являются входными данными, и мы можем установить степень масштабирования угла и длины, используя плавающие входные параметры «Радиальная шкала» и «Масштаб длины» соответственно. Результатом является новый набор UV в этой полярной системе координат."}},{"model":"main.shader","pk":97,"fields":{"title":"₉₇ Flipbook","textEng":"The Flipbook node is very useful if you’re trying to make a flipbook animation, especially for sprites. The UV input is the same as the UV input on any of these nodes so far, and we can also supply the Width and Height as floats, which should be the number of flipbook tiles on your texture in the x- and y-direction. The Tile input will determine which tile you want to sample, and Unity will calculate new UVs which pick only that part of the texture, which becomes the output.  The direction of the UVs, in other words the order in which the Tile input picks tiles, is determined by the Invert X and Invert Y options. By default, Invert Y is ticked, and tiles are picked starting from the top-left and moving horizontally first. Typically, you would use the output UVs in a Sample Texture 2D node to sample whatever texture you had in mind.","textRus":"Узел Flipbook очень полезен, если вы пытаетесь создать анимацию флипбука, особенно для спрайтов. Входные данные UV такие же, как входные данные UV на любом из этих узлов, и мы также можем указать Ширину и Высоту в виде чисел с плавающей запятой, что должно соответствовать количеству тайлов флипбука на вашей текстуре в направлении x и y. Входные данные Tile определят, какой тайл вы хотите сэмплировать, а Unity рассчитает новые UV-развертки, которые выбирают только ту часть текстуры, которая становится выходными данными. Направление UV, другими словами, порядок, в котором вход Tile выбирает плитки, определяется опциями Invert X и Invert Y. По умолчанию установлен флажок «Инвертировать Y», и плитки выбираются, начиная с верхнего левого угла и сначала перемещаясь по горизонтали. Обычно вы используете выходные UV-развертки в узле Sample Texture 2D, чтобы сэмплировать любую текстуру, которую вы задумали."}},{"model":"main.shader","pk":98,"fields":{"title":"₉₈ Parallax Mapping","textEng":"The Parallax Mapping node can be used to fake depth inside your material by displacing the UVs. We can supply a Heightmap, which is a greyscale texture controlling how high or low each part of the surface should be. Together with that, we can add a Sampler State. The Amplitude float is a multiplier, in centimetres, for the heights read from the heightmap, and the UVs are used for sampling the heightmap. The output Parallax UVs are the modified UVs which can be used to sample another texture with parallax applied.","textRus":"Узел Parallax Mapping можно использовать для имитации глубины внутри вашего материала путем смещения UV. Мы можем предоставить карту высот, которая представляет собой текстуру в оттенках серого, контролирующую, насколько высокой или низкой должна быть каждая часть поверхности. Вместе с этим мы можем добавить состояние Sampler. Плавающее значение Amplitude представляет собой множитель в сантиметрах для высот, считываемых из карты высот, а UV используются для выборки карты высот. Выходные UV-объекты параллакса — это модифицированные UV-объекты, которые можно использовать для выборки другой текстуры с примененным параллаксом."}},{"model":"main.shader","pk":99,"fields":{"title":"₉₉ Parallax Occlusion Mapping","textEng":"The Parallax Occlusion Mapping node acts the same way as the Parallax Mapping node, except the latter doesn’t take occlusion into account – higher parts of the heightmap can obscure lighting on lower parts. Now we have three added parameters: the Steps parameter controls how many times the internal algorithm runs in order to detect occlusion – higher values means more accuracy, but slower runtime.","textRus":"Узел Parallax Occlusion Mapping действует так же, как и узел Parallax Mapping, за исключением того, что последний не учитывает окклюзию — более высокие части карты высот могут затенять освещение в нижних частях. Теперь у нас есть три добавленных параметра: параметр «Шаги» контролирует, сколько раз внутренний алгоритм запускается для обнаружения окклюзии — более высокие значения означают большую точность, но более медленное время выполнения."}},{"model":"main.shader","pk":100,"fields":{"title":"₁₀₀ Add","textEng":"Now we can take a rest with some super simple nodes! I bet you can’t guess what the Add node does. It takes two float inputs, and the output is those two added together.","textRus":"Теперь мы можем отдохнуть с некоторыми супер простыми узлами! Могу поспорить, вы не догадаетесь, что делает узел Add. Он принимает два входных значения с плавающей запятой, а выходные данные складываются вместе."}},{"model":"main.shader","pk":101,"fields":{"title":"₁₀₁ Subtract","textEng":"The Subtract node, on the other hand, takes the A input and subtracts the B input.","textRus":"Узел Subtract, с другой стороны, принимает входные данные A и вычитает входные данные B."}},{"model":"main.shader","pk":102,"fields":{"title":"₁₀₂ Multiply","textEng":"The Multiply node takes your two inputs and multiplies them together, although this is more in-depth than other basic maths nodes. If both inputs are floats, they are multiplied together, and if they’re both vectors, it’ll multiply them together element-wise, and return a new vector the same size as the smaller input. If both inputs are matrices, the node will truncate them so that they are the same size and perform matrix multiplication between the two, outputting a new matrix the same size as the smaller input. And if a vector and a matrix are input, the node will add elements to the vector until it is large enough, then multiply the two.","textRus":"Узел «Умножение» принимает два входных значения и перемножает их, хотя он более глубокий, чем другие узлы базовой математики. Если оба входных значения являются числами с плавающей запятой, они умножаются вместе, а если они оба являются векторами, они перемножаются поэлементно и возвращают новый вектор того же размера, что и меньший входной сигнал. Если оба входа являются матрицами, узел усекает их, чтобы они имели одинаковый размер, и выполняет умножение матриц между ними, выводя новую матрицу того же размера, что и меньший вход. А если введены вектор и матрица, узел будет добавлять элементы к вектору до тех пор, пока он не станет достаточно большим, а затем умножать их."}},{"model":"main.shader","pk":103,"fields":{"title":"₁₀₃ Divide","textEng":"The Divide node also takes in two floats and returns the A input divided by the B input.","textRus":"Узел Divide также принимает два числа с плавающей запятой и возвращает входное значение A, разделенное на входное значение B."}},{"model":"main.shader","pk":104,"fields":{"title":"₁₀₄ Power","textEng":"The Power node takes in two floats and returns the first input raised to the power of the second input.","textRus":"Узел Power принимает два числа с плавающей запятой и возвращает первое входное значение, возведенное в степень второго входного значения."}},{"model":"main.shader","pk":105,"fields":{"title":"₁₀₅ Square Root","textEng":"And finally, the Square Root node takes in a single float and returns its square root.","textRus":"И, наконец, узел квадратного корня принимает одно число с плавающей запятой и возвращает его квадратный корень."}},{"model":"main.shader","pk":106,"fields":{"title":"₁₀₆ Lerp","textEng":"The Lerp node is extremely versatile. Lerp is short for “linear interpolation” – we take in two inputs, A and B, which can be vectors of up to four components. If you supply vectors of different sizes, Unity will discard the extra channels from the larger one. We also take a T input, which can be the same size as those input vectors, or it can be a single float. T is clamped between 0 and 1. Interpolation draws a straight line between the A and B inputs and picks a point on the line based on T – if T is 0.25, the point is 25% between A and B, for example. If T has more than one component, the interpolation is applied per-component, but if it is a single float, then that same value is used for each of A and B’s components. The output is the value that got picked.","textRus":"Узел Lerp чрезвычайно универсален. Lerp — это сокращение от «линейная интерполяция» — мы принимаем два входных параметра, A и B, которые могут быть векторами, содержащими до четырех компонентов. Если вы предоставите векторы разных размеров, Unity отбросит лишние каналы из большего. Мы также берем на вход T, который может быть того же размера, что и эти входные векторы, или это может быть одно число с плавающей запятой. T фиксируется между 0 и 1. Интерполяция рисует прямую линию между входами A и B и выбирает точку на линии на основе T — если T равно 0,25, например, точка составляет 25% между A и B. Если T имеет более одного компонента, интерполяция применяется для каждого компонента, но если это одно число с плавающей запятой, то одно и то же значение используется для каждого из компонентов A и B. Результатом является выбранное значение."}},{"model":"main.shader","pk":107,"fields":{"title":"₁₀₇ Inverse Lerp","textEng":"The Inverse Lerp node does the inverse process to Lerp. Given input values A, B and T, Inverse Lerp will work out what interpolation factor between 0 and 1 would have been required in a Lerp node to output T. I hope that makes sense!","textRus":"Узел Inverse Lerp выполняет процесс, обратный Lerp. Учитывая входные значения A, B и T, Inverse Lerp определит, какой коэффициент интерполяции между 0 и 1 потребовался бы в узле Lerp для вывода T. Надеюсь, это имеет смысл!"}},{"model":"main.shader","pk":108,"fields":{"title":"₁₀₈ Smoothstep","textEng":"Smoothstep is a special sigmoid function which can be used for creating a smooth but swift gradient when an input value crosses some threshold. The In parameter is your input value. The node takes two Edge parameters, which determine the lower and higher threshold values for the curve. When In is lower than Edge 1, the output is 0, and when In is above Edge 2, the output is 1. Between those thresholds, the output is a smooth curve between 0 and 1.","textRus":"Smoothstep — это специальная сигмовидная функция, которую можно использовать для создания плавного, но быстрого градиента, когда входное значение пересекает некоторый порог. Параметр In — это ваше входное значение. Узел принимает два параметра Edge, которые определяют нижнее и верхнее пороговые значения кривой. Когда In ниже Edge 1, выходной сигнал равен 0, а когда In выше Edge 2, выходной сигнал равен 1. Между этими пороговыми значениями выходной сигнал представляет собой плавную кривую между 0 и 1."}},{"model":"main.shader","pk":109,"fields":{"title":"₁₀₉ Clamp","textEng":"The Clamp node takes in an input vector of up to four elements, and will clamp the values element-wise so that they never fall below the Min input and are never above the Max input. The output is the vector after clamping.","textRus":"Узел Clamp принимает входной вектор, содержащий до четырех элементов, и фиксирует значения поэлементно, чтобы они никогда не падали ниже входного значения Min и никогда не превышали входного значения Max. Выходными данными являются вектор после фиксации."}},{"model":"main.shader","pk":110,"fields":{"title":"₁₁₀ Saturate","textEng":"The Saturate node is like a Clamp node, except the min and max values are always 0 and 1.","textRus":"Нод Saturate похож на нод Clamp, за исключением того, что минимальные и максимальные значения всегда равны 0 и 1."}},{"model":"main.shader","pk":111,"fields":{"title":"₁₁₁ Minimum","textEng":"The Minimum node takes in two vector inputs and outputs a vector of the same size where each element takes the lowest value from the corresponding elements on the two inputs. If you input two floats, it just takes the lower one.","textRus":"Узел Минимум принимает два входных вектора и выводит вектор одинакового размера, где каждый элемент принимает наименьшее значение из соответствующих элементов на двух входах. Если вы введете два числа с плавающей точкой, будет использовано только нижнее."}},{"model":"main.shader","pk":112,"fields":{"title":"₁₁₂ Maximum","textEng":"And the Maximum node does a similar thing, except it returns the higher number for each component of the input vectors.","textRus":"Узел Максимум делает то же самое, за исключением того, что возвращает большее число для каждого компонента входных векторов."}},{"model":"main.shader","pk":113,"fields":{"title":"₁₁₃ One Minus","textEng":"The One Minus node takes each component of the input vector and returns one, minus that value. Shocking, I know.","textRus":"Узел «Один минус» принимает каждый компонент входного вектора и возвращает один минус это значение. Шокирующе, я знаю."}},{"model":"main.shader","pk":114,"fields":{"title":"₁₁₄ Remap","textEng":"The Remap node is a special type of interpolation. We take an input vector of up to four elements. Then we take two Vector 2 inputs: one is the In Min Max vector which specifies the minimum and maximum values that the input should have. The Out Min Max vector specifies the minimum and maximum value the output should have. So this node ends up, essentially, performing an Inverse Lerp with the input value and In Min Max to determine the interpolation factor, then does a Lerp using that interpolation factor between the Out Min Max values. The results are then output.","textRus":"Узел Remap — это особый тип интерполяции. Мы берем входной вектор, содержащий до четырех элементов. Затем мы берем два входных сигнала вектора 2: один — это вектор In Min Max, который определяет минимальное и максимальное значения, которые должен иметь входной сигнал. Вектор Out Min Max определяет минимальное и максимальное значение, которое должен иметь выходной сигнал. Таким образом, этот узел, по сути, выполняет обратный Lerp с входным значением и In Min Max для определения коэффициента интерполяции, а затем выполняет Lerp, используя этот коэффициент интерполяции между значениями Out Min Max. Затем выводятся результаты."}},{"model":"main.shader","pk":115,"fields":{"title":"₁₁₅ Random Range","textEng":"The Random Range node can be used to generate pseudo-random numbers between the Min and Max input floats. We specify a Vector 2 to use as the input seed value, and then a single float is output. This node is great for generating random noise, but since we specify the seed, you can use the position of, for example, fragments in object space so that your output values stay consistent between frames. Or you could use time as an input to randomise values between frames.","textRus":"Узел Random Range можно использовать для генерации псевдослучайных чисел между входными числами с плавающей запятой Min и Max. Мы указываем вектор 2, который будет использоваться в качестве входного начального значения, а затем выводится одно число с плавающей запятой. Этот узел отлично подходит для генерации случайного шума, но поскольку мы указываем начальное число, вы можете использовать положение, например, фрагментов в пространстве объектов, чтобы ваши выходные значения оставались согласованными между кадрами. Или вы можете использовать время в качестве входных данных для рандомизации значений между кадрами."}},{"model":"main.shader","pk":116,"fields":{"title":"₁₁₆ Fraction","textEng":"The Fraction node takes an input vector, and for each component, returns a new vector where each value takes the portion after the decimal point. The output, therefore, is always between 0 and 1.","textRus":"Узел «Дробь» принимает входной вектор и для каждого компонента возвращает новый вектор, где каждое значение занимает часть после десятичной точки. Таким образом, выход всегда находится между 0 и 1."}},{"model":"main.shader","pk":117,"fields":{"title":"₁₁₇ Floor","textEng":"The Floor node takes a vector as input, and for each component, returns the largest whole number lower or equal to that value.","textRus":"Узел Floor принимает вектор в качестве входных данных и для каждого компонента возвращает наибольшее целое число, меньшее или равное этому значению."}},{"model":"main.shader","pk":118,"fields":{"title":"₁₁₈ Ceiling","textEng":"The Ceiling node is similar, except it takes the next whole number greater than or equal to the input.","textRus":"Узел «Потолок» аналогичен, за исключением того, что он принимает следующее целое число, большее или равное входному."}},{"model":"main.shader","pk":119,"fields":{"title":"₁₁₉ Round","textEng":"And the Round node is also similar, except it rounds up or down to the nearest whole number.","textRus":"Узел Round также аналогичен, за исключением того, что он округляет вверх или вниз до ближайшего целого числа."}},{"model":"main.shader","pk":120,"fields":{"title":"₁₂₀ Sign","textEng":"The Sign node takes in a vector and for each component, returns 1 if the value is greater than zero, 0 if it is zero, and -1 if it is below zero.","textRus":"Узел Sign принимает вектор и для каждого компонента возвращает 1, если значение больше нуля, 0, если оно равно нулю, и -1, если оно ниже нуля."}},{"model":"main.shader","pk":121,"fields":{"title":"₁₂₁ Step","textEng":"The Step node is a very useful function that takes in an input called In, and if that is below the Edge input, the output is 0. Else, if In is above the Edge input, the output becomes 1. If a vector input is used, it operates per-element.","textRus":"Узел Step — очень полезная функция, которая принимает входные данные с именем In, и если они ниже входных данных Edge, выходное значение равно 0. В противном случае, если In выше входных данных Edge, выходные данные становятся 1. Если векторные входные данные равны используется, он работает для каждого элемента."}},{"model":"main.shader","pk":122,"fields":{"title":"₁₂₂ Truncate","textEng":"The Truncate node takes an input float and removes the fractional part. It seemingly works the same as Floor, except it works differently on negative numbers. For instance, -0.3 will floor to -1, but it truncates to 0.","textRus":"Узел Truncate принимает входное число с плавающей запятой и удаляет дробную часть. Похоже, он работает так же, как Floor, за исключением того, что он работает по-другому с отрицательными числами. Например, -0,3 будет уменьшено до -1, но усекается до 0."}},{"model":"main.shader","pk":123,"fields":{"title":"₁₂₃ Noise Sine Wave","textEng":"The Noise Sine Wave node will return the sine of the input value, but will apply a small pseudorandom noise to the value. The size of the noise is random between the min and max values specified in the Min Max Vector 2. The output is just the sine wave value.","textRus":"Узел Noise Sine Wave вернет синус входного значения, но применит к значению небольшой псевдослучайный шум. Размер шума является случайным между минимальным и максимальным значениями, указанными в Min Max Vector 2. Выходной сигнал представляет собой просто значение синусоидальной волны."}},{"model":"main.shader","pk":124,"fields":{"title":"₁₂₄ Square Wave","textEng":"A Square Wave is one that constantly switches between the values -1 and 1 at a regular interval. The Square Wave node takes in an input value and returns a square wave using that as the time parameter. If you connect a Time node, then it will complete a cycle each second.","textRus":"Прямоугольная волна — это волна, которая постоянно переключается между значениями -1 и 1 через равные промежутки времени. Узел прямоугольной волны принимает входное значение и возвращает прямоугольную волну, используя его в качестве параметра времени. Если вы подключите узел Времени, он будет совершать цикл каждую секунду."}},{"model":"main.shader","pk":125,"fields":{"title":"₁₂₅ Triangle Wave","textEng":"A Triangle Wave rises from -1 to 1 linearly, then falls back to -1 linearly. The curve looks like a series of triangular peaks, hence the name. This node goes from -1 to 1 to -1 again over an interval of one second.","textRus":"Треугольная волна линейно возрастает от -1 до 1, а затем линейно падает до -1. Кривая выглядит как серия треугольных пиков, отсюда и название. Этот узел переходит от -1 к 1 и снова к -1 с интервалом в одну секунду."}},{"model":"main.shader","pk":126,"fields":{"title":"₁₂₆ Sawtooth Wave","textEng":"A Sawtooth Wave rises -1 to 1 linearly, then instantaneously drops back down to -1. The curve looks like a series of sharp peaks, like a saw. This node completes one cycle of going from -1 to 1 within a second.","textRus":"Пилообразная волна линейно возрастает от -1 до 1, а затем мгновенно падает обратно до -1. Кривая выглядит как серия острых пиков, как пила. Этот узел завершает один цикл перехода от -1 к 1 за секунду."}},{"model":"main.shader","pk":127,"fields":{"title":"₁₂₇ Sine, ₁₂₈ Cosine, ₁₂₉ Tangent","textEng":"The Sine, Cosine and Tangent nodes perform the corresponding basic trig function on the input, which is an angle in radians. Sine and Cosine return values between -1 and 1, where Tangent may return values from -Infinity to Infinity. Sine and cosine functions are used under the hood during cross product calculations.","textRus":"Узлы Синус, Косинус и Тангенс выполняют соответствующую базовую триггерную функцию на входе, который представляет собой угол в радианах. Синус и косинус возвращают значения от -1 до 1, где Тангенс может возвращать значения от -Бесконечности до Бесконечности. Функции синуса и косинуса используются «под капотом» во время вычислений векторного произведения."}},{"model":"main.shader","pk":128,"fields":{"title":"₁₃₀ Arcsine, ₁₃₁ Arccosine, ₁₃₂ Arctangent","textEng":"The Arcsine, Arccosine and Arctangent nodes do the opposite - these are the inverse trig functions, and we can use them to get back the angle from our input value (where the input is a valid output value from one of Sine, Cosine or Tangent). All the outputs are in radians: Arcsine accepts values between -1 and 1 and will return an angle between minus pi over 2 and pi over 2; Arccosine accepts inputs from -1 to 1, but this time returns the angle between 0 and pi; and the Arctangent node takes any Float value as input and returns an angle between minus pi over 2 and pi over 2, like Sine.","textRus":"Узлы Арксинус, Арккосинус и Арктангенс делают противоположное — это обратные триггерные функции, и мы можем использовать их, чтобы получить угол из нашего входного значения (где входными данными является допустимое выходное значение одного из синуса, косинуса или тангенса). . Все выходные данные представлены в радианах: Арксинус принимает значения от -1 до 1 и возвращает угол между минус пи более 2 и пи более 2; Арккосинус принимает входные значения от -1 до 1, но на этот раз возвращает угол между 0 и пи; а узел Арктангенс принимает любое значение с плавающей запятой в качестве входных данных и возвращает угол между минус пи больше 2 и пи больше 2, например, синус."}},{"model":"main.shader","pk":129,"fields":{"title":"₁₃₃ Arctangent2","textEng":"Arctangent2 is the two-argument arctangent function. Given inputs A and B, it gives the angle between the x-axis of a two-dimensional plane and the point vector (B, A).","textRus":"Arctangent2 — это функция арктангенса с двумя аргументами. Учитывая входные данные A и B, он дает угол между осью X двумерной плоскости и точечным вектором (B, A)."}},{"model":"main.shader","pk":130,"fields":{"title":"₁₃₄ Degrees To Radians","textEng":"The Degrees To Radians node takes whatever the input float is, assumes it’s in degrees, and multiplies it by a constant such that the output is the same angle in radians.","textRus":"Узел «Градусы в радианы» принимает значение входного числа с плавающей запятой, предполагает, что оно указано в градусах, и умножает его на константу, так что на выходе получается тот же угол в радианах."}},{"model":"main.shader","pk":131,"fields":{"title":"₁₃₅ Radians To Degrees","textEng":"The Radians To Degrees node does the opposite of Degrees To Radians - give it a radian value, and it’ll return the equivalent value in degrees.","textRus":"Узел «Радиан в градусы» выполняет противоположное действие «Градусы в радианы»: задайте ему значение в радианах, и он вернет эквивалентное значение в градусах."}},{"model":"main.shader","pk":132,"fields":{"title":"₁₃₆ Hyperbolic Sine, ₁₃₇ Hyperbolic Cosine, ₁₃₈ Hyperbolic Tangent","textEng":"And finally, the Hyperbolic Sine, Hyperbolic Cosine and Hyperbolic Tangent nodes perform the three hyperbolic trig functions on your input angle. The inputs and outputs are Float values.","textRus":"И, наконец, узлы «Гиперболический синус», «Гиперболический косинус» и «Гиперболический тангенс» выполняют три гиперболические тригонометрические функции для вашего входного угла. Входные и выходные данные являются значениями с плавающей запятой."}},{"model":"main.shader","pk":133,"fields":{"title":"₁₃₉ Distance","textEng":"The Distance node takes in two vectors and returns, as a float, the Euclidean distance between the two vectors. That’s the straight-line distance between the two.","textRus":"Узел Distance принимает два вектора и возвращает в виде числа с плавающей запятой евклидово расстояние между двумя векторами. Это расстояние по прямой между ними."}},{"model":"main.shader","pk":134,"fields":{"title":"₁₄₀ Dot Product","textEng":"The Dot Product is a measure of the angle between two vectors. When two vectors are perpendicular, the dot product is zero, and when they are parallel, it is either 1 or minus 1 depending on whether they point in the same or the opposite direction respectively. The dot product node takes in two vectors and returns the dot product between them as a Float.","textRus":"Скалярное произведение — это мера угла между двумя векторами. Когда два вектора перпендикулярны, скалярное произведение равно нулю, а когда они параллельны, оно равно 1 или минус 1 в зависимости от того, указывают ли они в одном или противоположном направлении соответственно. Узел скалярного произведения принимает два вектора и возвращает скалярное произведение между ними в виде числа с плавающей запятой."}},{"model":"main.shader","pk":135,"fields":{"title":"₁₄₁ Cross Product","textEng":"The Cross Product between two vectors returns a third vector which is perpendicular to both. You will probably use the cross product to get directions, so magnitude doesn’t matter as much, but for clarity, the magnitude of the third vector is equal to the magnitude of the two inputs multiplied by the sine of the angle between them. The cross product node performs the cross product on the two inputs, which must be Vector 3s, and outputs a new Vector 3 – the direction is based on the left-hand rule for vectors. In other words, if vector A points up and vector B points right, the output vector points forward.","textRus":"Перекрестное произведение между двумя векторами возвращает третий вектор, который перпендикулярен обоим. Вероятно, вы будете использовать векторное произведение для определения направления, поэтому величина не имеет большого значения, но для ясности величина третьего вектора равна величине двух входных данных, умноженной на синус угла между ними. Узел векторного произведения выполняет векторное произведение двух входных данных, которые должны быть векторами 3, и выводит новый вектор 3 — направление основано на правиле левой руки для векторов. Другими словами, если вектор A направлен вверх, а вектор B — вправо, выходной вектор направлен вперед."}},{"model":"main.shader","pk":136,"fields":{"title":"₁₄₂ Transform","textEng":"The Transform node can be used to convert from one space to another. The input is a Vector 3 and the output is another Vector 3 after the transform has taken place. The node has two controls on its body which you can use to pick the Space you want to convert from and to – you can pick between many of the spaces we’ve mentioned before: Object, View, World, Tangent and Absolute World. You can also choose the Type with a third control option, which lets you pick between Position and Direction.","textRus":"Узел Transform можно использовать для преобразования одного пространства в другое. На входе — вектор 3, а на выходе — другой вектор 3 после завершения преобразования. Узел имеет два элемента управления на своем теле, которые вы можете использовать для выбора пространства, из которого вы хотите конвертировать, и в которое вы можете выбирать между многими пространствами, о которых мы упоминали ранее: «Объект», «Вид», «Мир», «Касательный» и «Абсолютный мир». Вы также можете выбрать тип с третьей опцией управления, которая позволяет выбирать между положением и направлением."}},{"model":"main.shader","pk":137,"fields":{"title":"₁₄₃ Fresnel Effect","textEng":"The Fresnel Effect node is another great node which can be used for adding extra lighting to objects at a grazing angle – specifically, it calculates the angle between the surface normal and the view direction. If applied to a sphere, you’ll see light applied to the ‘edge’, which is easy to see on the node preview. The inputs to the node are the surface Normal and View Dir, both of which are Vector 3s assumed to be in world space, and a float called Power, which can be used to sharpen the Fresnel effect. The output is a single float which represents the overall strength of the Fresnel.","textRus":"Нод «Эффект Френеля» — еще один замечательный узел, который можно использовать для добавления дополнительного освещения к объектам под углом скольжения — в частности, он вычисляет угол между нормалью поверхности и направлением обзора. При применении к сфере вы увидите свет, примененный к «краю», что легко увидеть при предварительном просмотре узла. Входными данными для узла являются поверхности Normal и View Dir, оба из которых являются векторами 3, предположительно находящимися в мировом пространстве, а также плавающий элемент Power, который можно использовать для усиления эффекта Френеля. Выходные данные представляют собой одно число с плавающей запятой, которое представляет общую силу Френеля."}},{"model":"main.shader","pk":138,"fields":{"title":"₁₄₄ Reflection","textEng":"The Reflection node takes in an incident direction vector and a surface normal as the two inputs, and outputs a new vector which is the reflection of the incident vector using the normal vector as the mirror line.","textRus":"Узел «Отражение» принимает вектор направления падения и нормаль к поверхности в качестве двух входных данных и выводит новый вектор, который является отражением вектора падения, используя вектор нормали в качестве зеркальной линии."}},{"model":"main.shader","pk":139,"fields":{"title":"₁₄₅ Projection","textEng":"The Projection node takes two vectors, A and B, and projects A onto B to create the output vector. What this means is that we end up with a vector parallel to B, but possibly longer or shorter, depending on the length of A.","textRus":"Узел проекции принимает два вектора, A и B, и проецирует A на B, чтобы создать выходной вектор. Это означает, что в итоге мы получим вектор, параллельный B, но, возможно, длиннее или короче, в зависимости от длины A."}},{"model":"main.shader","pk":140,"fields":{"title":"₁₄₆ Rejection","textEng":"The Rejection node also takes two vectors, A and B, and returns a new vector pointing from the point on B closest to the endpoint of A, to the endpoint of A itself. The rejection vector is perpendicular to B. In fact, the rejection vector is equal to A minus the projection of A onto B.","textRus":"Узел отклонения также принимает два вектора, A и B, и возвращает новый вектор, указывающий из точки B, ближайшей к конечной точке A, к конечной точке самой A. Вектор отклонения перпендикулярен B. Фактически вектор отклонения равен A минус проекция A на B."}},{"model":"main.shader","pk":141,"fields":{"title":"₁₄₇ Rotate About Axis","textEng":"The Rotate About Axis node takes a Vector 3 Input and a second Vector 3 representing the Axis to rotate around, as well as a Rotation angle as a float. We also have a control on the node that lets us choose between degrees and radians for the rotation input. The node outputs the original vector rotated around the rotation axis by that amount.","textRus":"Узел «Поворот вокруг оси» принимает входные данные «Вектор 3» и второй вектор 3, представляющий ось для вращения, а также угол вращения в виде плавающего числа. У нас также есть элемент управления на узле, который позволяет нам выбирать между градусами и радианами для ввода вращения. Узел выводит исходный вектор, повернутый вокруг оси вращения на эту величину."}},{"model":"main.shader","pk":142,"fields":{"title":"₁₄₈ Sphere Mask","textEng":"The Sphere Mask takes a Coordinate, a position in any arbitrary space, and a sphere represented by a Centre point and a Radius. If the original position is within the sphere, the output is 1. Else, it is zero. Although, there’s also a Hardness parameter, which is designed to be between 0 and 1, which you can use to smoothen the falloff between 0 and 1 outputs. The higher the hardness parameter, the sharper the transition. If you want it to be a hard border, set it to 1.","textRus":"Маска сферы принимает координату, положение в любом произвольном пространстве и сферу, представленную центральной точкой и радиусом. Если исходное положение находится внутри сферы, выходной сигнал равен 1. В противном случае он равен нулю. Хотя есть также параметр Hardness, который рассчитан на значение от 0 до 1, и который вы можете использовать для сглаживания спада между выходными значениями 0 и 1. Чем выше параметр твердости, тем резче переход. Если вы хотите, чтобы граница была жесткой, установите значение 1."}},{"model":"main.shader","pk":143,"fields":{"title":"₁₄₉ DDX","textEng":"The DDX node can be used to take a derivative in the x-direction. This works by calculating the input to the node for this pixel and the adjacent horizontal pixel and taking the difference between them. The output is that difference. You can do this without sacrificing efficiency because during the rasterization process, fragments get processed in 2x2 tiles, so it’s very easy for a shader to calculate values on adjacent pixels in this group of tiles.","textRus":"Узел DDX можно использовать для получения производной в направлении x. Это работает путем вычисления входных данных узла для этого пикселя и соседнего горизонтального пикселя и определения разницы между ними. Результатом является эта разница. Вы можете сделать это, не жертвуя эффективностью, поскольку в процессе растеризации фрагменты обрабатываются в тайлах 2x2, поэтому шейдеру очень легко вычислять значения для соседних пикселей в этой группе тайлов."}},{"model":"main.shader","pk":144,"fields":{"title":"₁₅₀ DDY","textEng":"The DDY node does a similar derivative, except vertically. It takes this pixel and the adjacent pixel vertically and returns the difference between their inputs to this node.","textRus":"Узел DDY выполняет аналогичную производную, но по вертикали. Он принимает этот пиксель и соседний пиксель по вертикали и возвращает разницу между их входными данными в этот узел."}},{"model":"main.shader","pk":145,"fields":{"title":"₁₅₁ DDXY","textEng":"And finally, DDXY takes the derivative diagonally by returning the sum of the two derivatives horizontally and vertically. In effect, it’s like adding DDX and DDY on the same input and taking the absolute value. All three derivative nodes are only available in the fragment shader stage. You might use them for something like edge detection by reading the values from Scene Color or Scene Depth and detecting where there’s a massive difference between adjacent pixels.","textRus":"И, наконец, DDXY берет производную по диагонали, возвращая сумму двух производных по горизонтали и вертикали. По сути, это похоже на добавление DDX и DDY к одному и тому же входу и получение абсолютного значения. Все три производных узла доступны только на этапе фрагментного шейдера. Вы можете использовать их для чего-то вроде обнаружения границ, считывая значения цвета сцены или глубины сцены и обнаруживая огромную разницу между соседними пикселями."}},{"model":"main.shader","pk":146,"fields":{"title":"₁₅₂ Matrix Construction","textEng":"The Matrix Construction node can be used to create new matrices using vectors. The node has four inputs, each of which is a Vector 4, corresponding to the maximum matrix size of 4x4. The node has a setting to determine whether the inputs are row or column vectors, and three inputs of varying size – so you can use this node to construct a 2x2, 3x3 or 4x4 matrix.","textRus":"Узел «Построение матрицы» можно использовать для создания новых матриц с использованием векторов. Узел имеет четыре входа, каждый из которых представляет собой вектор 4, что соответствует максимальному размеру матрицы 4x4. У узла есть настройка, позволяющая определить, являются ли входные данные векторами-строками или столбцами, а также три входных параметра разного размера — поэтому вы можете использовать этот узел для построения матрицы 2x2, 3x3 или 4x4."}},{"model":"main.shader","pk":147,"fields":{"title":"₁₅₃ Matrix Split","textEng":"The Matrix Split node, on the other hand, takes in a matrix and lets us split the matrix into several vectors. The input matrix can be between 2x2 and 4x4, and the output Vector 4s will be partially filled with zeroes if the matrix is smaller than 4x4. As with the Matrix Construction node, we can choose whether the output vectors are row or column vectors.","textRus":"С другой стороны, узел «Разделение матрицы» принимает матрицу и позволяет нам разделить ее на несколько векторов. Входная матрица может иметь размер от 2x2 до 4x4, а выходные вектора 4 будут частично заполнены нулями, если матрица меньше 4x4. Как и в случае с узлом «Построение матрицы», мы можем выбрать, будут ли выходные векторы векторами-строками или векторами-столбцами."}},{"model":"main.shader","pk":148,"fields":{"title":"₁₅₄ Matrix Determinant","textEng":"The determinant of a matrix is a common operation in maths, and the Matrix Determinant node calculates it for you. The input is a matrix of any size between 2x2 and 4x4, and the output is its determinant. This can be a bit costly for large matrices, so use it sparingly.","textRus":"Определитель матрицы — это обычная операция в математике, и узел Определитель матрицы вычисляет ее за вас. Входные данные представляют собой матрицу любого размера от 2x2 до 4x4, а выходные данные — ее определитель. Это может быть немного дороговато для больших матриц, поэтому используйте его экономно."}},{"model":"main.shader","pk":149,"fields":{"title":"₁₅₅ Matrix Transpose","textEng":"The Matrix Transpose node reflects the elements of the matrix in its leading diagonal, such that the rows become columns and vice versa. The input and output are both matrices of the same size.","textRus":"Узел «Транспонирование матрицы» отражает элементы матрицы по ее главной диагонали, так что строки становятся столбцами и наоборот. Входные и выходные данные представляют собой матрицы одинакового размера."}},{"model":"main.shader","pk":150,"fields":{"title":"₁₅₆ Absolute","textEng":"The Absolute node returns the absolute value of the input – in other words, if the input value is negative, the sign becomes positive. The input can be a vector, and if so, the operation is performed to each element. That applies to a lot of these nodes, so sometimes I’ll just mention a float input even if it can take a vector.","textRus":"Узел «Абсолют» возвращает абсолютное значение входных данных — другими словами, если входное значение отрицательное, знак становится положительным. Входными данными может быть вектор, и если да, то операция выполняется для каждого элемента. Это относится ко многим из этих узлов, поэтому иногда я просто упоминаю входные данные с плавающей запятой, даже если они могут принимать вектор."}},{"model":"main.shader","pk":151,"fields":{"title":"₁₅₇ Length","textEng":"The Length node takes a vector as input and returns its length, which is calculated using Pythagoras’ Theorem.","textRus":"Узел «Длина» принимает вектор в качестве входных данных и возвращает его длину, которая рассчитывается с использованием теоремы Пифагора."}},{"model":"main.shader","pk":152,"fields":{"title":"₁₅₈ Modulo","textEng":"Modulo arithmetic works by counting up until you reach some value, at which point you start counting from zero again. In other words, the Modulo node gives the remainder after dividing input A by input B.","textRus":"Арифметика по модулю работает путем подсчета до тех пор, пока не будет достигнуто определенное значение, после чего вы снова начнете считать с нуля. Другими словами, узел Modulo дает остаток после деления входа A на вход B."}},{"model":"main.shader","pk":153,"fields":{"title":"₁₅₉ Negate","textEng":"The Negate node flips the sign of the input float.","textRus":"Узел Negate меняет знак входного числа с плавающей запятой."}},{"model":"main.shader","pk":154,"fields":{"title":"₁₆₀ Normalize","textEng":"The Normalize node takes in a vector and returns a new vector pointing in the same direction, but with length 1.","textRus":"Узел нормализации принимает вектор и возвращает новый вектор, указывающий в том же направлении, но с длиной 1."}},{"model":"main.shader","pk":155,"fields":{"title":"₁₆₁ Posterize","textEng":"The Posterize node takes in an input value and a step value. This node will clamp the range of the input between 0 and 1 and quantise its value so that it can only take a number of values equal to the number of steps supplied, plus one. For example, if the number of steps is 4, then the output is rounded down to the values 0, 0.25, 0.5, 0.75 or 1.","textRus":"Узел Posterize принимает входное значение и значение шага. Этот узел будет ограничивать диапазон входных данных от 0 до 1 и квантовать его значение так, чтобы он мог принимать только количество значений, равное количеству предоставленных шагов плюс один. Например, если количество шагов равно 4, то результат округляется до значений 0, 0,25, 0,5, 0,75 или 1."}},{"model":"main.shader","pk":156,"fields":{"title":"₁₆₂ Reciprocal","textEng":"The Reciprocal node divides one by the input float. We have an option to pick the algorithm used for the calculation – either Default, or Fast, which is less accurate, but good if you’re using Reciprocal a lot.","textRus":"Узел Reciprocal делит единицу на входное число с плавающей запятой. У нас есть возможность выбрать алгоритм, используемый для расчета: «По умолчанию» или «Быстрый», что менее точно, но хорошо, если вы часто используете Reciprocal."}},{"model":"main.shader","pk":157,"fields":{"title":"₁₆₃ Reciprocal Square Root","textEng":"The Reciprocal Square Root node is similar to Reciprocal, except it calculates 1 divided by the square root of the input. Unlike Reciprocal, there’s no extra option to choose different methods. If you’re interested in a bit of history, the Fast Inverse Square Root method is a famous piece of code, pioneered by John Carmack but discovered earlier, for calculating the reciprocal square root of a number. It’s no longer necessary because this functionality is provided at the instruction set level, but it’s an interesting footnote.","textRus":"Узел «Взаимный квадратный корень» аналогичен узлу «Взаимный квадратный корень», за исключением того, что он вычисляет 1, разделенное на квадратный корень входных данных. В отличие от Reciprocal, здесь нет дополнительной возможности выбирать разные методы. Если вас интересует немного истории, то метод быстрого обратного квадратного корня — это известный фрагмент кода, впервые разработанный Джоном Кармаком, но обнаруженный ранее, для вычисления обратного квадратного корня из числа. В этом больше нет необходимости, поскольку эта функциональность обеспечивается на уровне набора команд, но это интересная сноска."}},{"model":"main.shader","pk":158,"fields":{"title":"₁₆₄ Exponential","textEng":"The Exponential node raises a particular number to the power of the float input. We can pick what the base number is by using the Base dropdown, which lets us choose between 2 and e. e is Euler’s number, which is approximately 2.72.","textRus":"Узел Экспонента возводит определенное число в степень входного числа с плавающей запятой. Мы можем выбрать базовое число, используя раскрывающийся список «База», который позволяет нам выбирать между 2 и e. e — число Эйлера, равное примерно 2,72."}},{"model":"main.shader","pk":159,"fields":{"title":"₁₆₅ Log","textEng":"The Log node does the opposite process as the Exponential node. If 2 to the power of 4 equals 16, then the log base 2 of 16 equals 4. We take in a float and return its log under a particular base. We can choose the base using the Base drop-down, except now we have the choice of 2, e or 10.","textRus":"Узел журнала выполняет процесс, противоположный узлу экспоненты. Если 2 в 4-й степени равно 16, то логарифмическое основание 2 из 16 равно 4. Мы берем число с плавающей запятой и возвращаем его логарифм по определенному основанию. Мы можем выбрать базу, используя раскрывающийся список «База», но теперь у нас есть выбор: 2, e или 10."}},{"model":"main.shader","pk":160,"fields":{"title":"₁₆₆ Blend","textEng":"The Blend node is normally used to blend one color into another. In this case, we pass a base color and a blend color into the node and we blend the Blend input onto the Base in put according to a third input, which is a float called Opacity. When Opacity is 0, the base is unaltered, and when Opacity is 1, the blending is at its strongest. There is also a Mode dropdown which lets us choose the method used for blending – there are a lot of options so I won’t go over every one. The only output is the color after the blending has been completed.","textRus":"Нод Blend обычно используется для смешивания одного цвета с другим. В этом случае мы передаем базовый цвет и цвет смешивания в узел и смешиваем входные данные Blend с вводом Base в соответствии с третьим входным значением, которое представляет собой плавающее число, называемое Opacity. Когда непрозрачность равна 0, основа не изменяется, а когда непрозрачность равна 1, смешивание максимально. Существует также раскрывающийся список «Режим», который позволяет нам выбрать метод, используемый для смешивания — вариантов много, поэтому я не буду рассматривать каждый. Единственным результатом является цвет после завершения смешивания."}},{"model":"main.shader","pk":161,"fields":{"title":"₁₆₇ Dither","textEng":"Dither is another of my favourite nodes. We use it in screen-space to apply intentional noise in some way – internally, the node defines a neat pattern of noise values which are used as thresholds. The input is a vector of values, and for each element, if its value is below the threshold defined by the dithering pattern, then the output is 0. Otherwise, it’s 1. We also require the Screen Position as input, and we can multiply this to scale the dithering effect.","textRus":"Дизеринг — еще один из моих любимых узлов. Мы используем его в экранном пространстве, чтобы каким-то образом применить намеренный шум — внутри узел определяет аккуратный шаблон значений шума, которые используются в качестве пороговых значений. Входные данные представляют собой вектор значений, и для каждого элемента, если его значение ниже порога, определенного шаблоном сглаживания, выходной сигнал равен 0. В противном случае это 1. Нам также требуется положение экрана в качестве входных данных, и мы можем умножить это для масштабирования эффекта размытия."}},{"model":"main.shader","pk":162,"fields":{"title":"₁₆₈ Color Mask","textEng":"The Color Mask node takes in an Input color, a Mask Color, and a Range float. If the input color is equal to the mask color, or within the range specified, then the output of the node is 1. Else, it is zero. However, there’s also a Fuzziness input. If we raise this above zero, then there will be a soft transition between 1 and 0 for values on the edge of the range. The output is a single float representing the mask value.","textRus":"Узел «Цветовая маска» принимает входной цвет, цвет маски и плавающий элемент «Диапазон». Если входной цвет равен цвету маски или находится в указанном диапазоне, то выходной сигнал узла равен 1. В противном случае он равен нулю. Однако есть также вход нечеткости. Если мы поднимем это значение выше нуля, то произойдет мягкий переход между 1 и 0 для значений на границе диапазона. Выходные данные представляют собой одно число с плавающей запятой, представляющее значение маски."}},{"model":"main.shader","pk":163,"fields":{"title":"₁₆₉ Channel Mask","textEng":"The Channel Mask node takes in a color as input. The Channels option on the node lets us pick any combination of channels. For each one that is selected, this node keeps colors in that channel, but discards color channels that are not picked by setting their values to zero. The output is the masked color.","textRus":"Узел «Маска канала» принимает цвет в качестве входных данных. Опция «Каналы» на узле позволяет нам выбирать любую комбинацию каналов. Для каждого выбранного узла этот узел сохраняет цвета в этом канале, но отбрасывает невыбранные цветовые каналы, устанавливая их значения равными нулю. Результатом является замаскированный цвет."}},{"model":"main.shader","pk":164,"fields":{"title":"₁₇₀ Hue","textEng":"The Hue node can be used to offset the hue of whatever color is passed as an input, using the amount specified by the Offset input. This node comes with a toggle between different Modes – for some reason, the documentation lists the options as Degrees and Radians, but on the node the options seem to be Degrees and Normalized. When Degrees is picked, you cycle through the entire range of hues between 0 and 360. And when Normalized is picked, the hue range is covered between an offset of 0 and 1.","textRus":"Узел Hue можно использовать для смещения оттенка любого цвета, передаваемого в качестве входных данных, используя величину, указанную входными данными Offset. Этот узел имеет переключатель между различными режимами — по какой-то причине в документации указаны параметры «Градусы» и «Радианы», но на узле параметры выглядят как «Градусы» и «Нормализация». При выборе «Градусы» вы циклически проходите весь диапазон оттенков от 0 до 360. А при выборе «Нормальный» диапазон оттенков охватывается смещением от 0 до 1."}},{"model":"main.shader","pk":165,"fields":{"title":"₁₇₁ Saturation","textEng":"The Saturation node adjusts the amount of saturation in the input color by whatever amount is passed into the Saturation float input. When the saturation value is 1, the original color’s saturation is left alone, and when it is zero, the output color will have no saturation at all.","textRus":"Узел «Насыщенность» регулирует степень насыщенности входного цвета в соответствии с любой величиной, передаваемой во входной плавающий параметр «Насыщенность». Когда значение насыщенности равно 1, насыщенность исходного цвета остается неизменной, а когда оно равно нулю, выходной цвет вообще не будет иметь насыщенности."}},{"model":"main.shader","pk":166,"fields":{"title":"₁₇₂ Contrast","textEng":"The Contrast node does a similar thing, except it adjusts the amount of contrast of the input color by whatever amount is used for the Contrast input float.","textRus":"Узел Контрастность делает то же самое, за исключением того, что он регулирует степень контрастности входного цвета на ту величину, которая используется для входного плавающего параметра Контраст."}},{"model":"main.shader","pk":167,"fields":{"title":"₁₇₃ White Balance","textEng":"The White Balance node is used for modifying the Tint and Temperature of an input color. Temperature is a bit hard to pin down, but generally speaking, cold colors are more blue and warm colors are more red, so reducing the temperature below 0 makes the color more blue and raising it above 0 makes things redder. Tint, on the other hand, tends to offset a color towards pink or green when it’s increased.","textRus":"Узел «Баланс белого» используется для изменения оттенка и температуры входного цвета. Температуру немного сложно определить, но, вообще говоря, холодные цвета более синие, а теплые цвета более красные, поэтому уменьшение температуры ниже 0 делает цвет более синим, а повышение ее выше 0 делает вещи более красными. С другой стороны, оттенок имеет тенденцию смещать цвет в сторону розового или зеленого, когда он увеличивается."}},{"model":"main.shader","pk":168,"fields":{"title":"₁₇₄ Replace Color","textEng":"The Replace Color node takes a color input, and we can define a color to replace, called From, and a color to replace it with, called To. Whenever the From color appears, it’s replaced with the To color. We also define a float called Range, which means that if any input color is within that range of From, it will also be replaced. And finally, increasing the Fuzziness input means there will be a smooth falloff between the original colors and the To color.","textRus":"Узел «Заменить цвет» принимает входные данные цвета, и мы можем определить цвет для замены, называемый From, и цвет для его замены, называемый To. Всякий раз, когда появляется цвет «От», он заменяется цветом «Кому». Мы также определяем число с плавающей запятой под названием Range, что означает, что если какой-либо входной цвет находится в этом диапазоне From, он также будет заменен. И, наконец, увеличение входного значения «Нечеткость» означает, что между исходными цветами и цветом «To» будет плавный переход."}},{"model":"main.shader","pk":169,"fields":{"title":"₁₇₅ Invert Colors","textEng":"The Invert Colors node takes an input color, and for each channel, returns one minus the channel. This node assumes the input colors are between 0 and 1 for each color channel, so this might act strange for HDR colors with high intensity.","textRus":"Узел «Инвертировать цвета» принимает входной цвет и для каждого канала возвращает один минус канал. Этот узел предполагает, что входные цвета находятся в диапазоне от 0 до 1 для каждого цветового канала, поэтому это может показаться странным для цветов HDR с высокой интенсивностью."}},{"model":"main.shader","pk":170,"fields":{"title":"₁₇₆ Channel Mixer","textEng":"The Channel Mixer node takes in a color input, and for each of the red, green and blue color channels, we can remap the amount they contribute to the output color’s red, green and blue channels. We do this by clicking one of the three buttons labelled R, G and B. When one is selected, modifying the sliders, which can run between -2 and 2, changes how much that input channel contributes to the three output channels. For example, if we select R, then make the sliders 0, 0 and 2, that means the input red contributes 200% to the output blue.","textRus":"Узел Channel Mixer принимает входной цвет, и для каждого из каналов красного, зеленого и синего цвета мы можем переназначить величину, которую они вносят в красный, зеленый и синий каналы выходного цвета. Мы делаем это, щелкая одну из трех кнопок с обозначениями R, G и B. Когда одна из них выбрана, изменение ползунков, которые могут находиться в диапазоне от -2 до 2, изменяет степень вклада этого входного канала в три выходных канала. Например, если мы выберем R, а затем установим ползунки на 0, 0 и 2, это означает, что входной красный будет составлять 200% выходного синего."}},{"model":"main.shader","pk":171,"fields":{"title":"₁₇₇ Normal Unpack","textEng":"The Normal Unpack node takes a color or vector as input and unpacks it into a normal vector. That said, for textures, you can usually sample it as a normal map anyway, so this node is more useful if you’ve generated a normal texture within the graph somehow and you need to convert from colors to normal vectors. You can choose the Space of the input between Tangent or Object space using the dropdown. The output normal vector is a Vector 3.","textRus":"Узел Normal Unpack принимает цвет или вектор в качестве входных данных и распаковывает его в вектор нормалей. Тем не менее, для текстур вы в любом случае можете сэмплировать их как карту нормалей, поэтому этот узел более полезен, если вы каким-то образом сгенерировали нормальную текстуру внутри графа и вам нужно преобразовать цвета в векторы нормалей. Вы можете выбрать пространство ввода между пространством касательной или пространством объекта, используя раскрывающийся список. Выходной вектор нормали — это вектор 3."}},{"model":"main.shader","pk":172,"fields":{"title":"₁₇₈ Normal Strength","textEng":"The Normal Strength node takes a set of normals as input as a Vector 3 and scales their strength via the Strength float input. A strength of 1 leaves the normals unaltered, while 0 will return a completely flat normal map with all the normals pointing upwards.","textRus":"Узел Normal Strength принимает набор нормалей в качестве входных данных в качестве вектора 3 и масштабирует их силу с помощью плавающего входа Strength. Сила 1 оставляет нормали без изменений, а 0 вернет совершенно плоскую карту нормалей со всеми нормалями, направленными вверх."}},{"model":"main.shader","pk":173,"fields":{"title":"₁₇₉ Normal From Texture","textEng":"The Normal From Texture node takes a Texture, a Sampler and a set of UVs as input and uses that as a heightmap, from which it will generate normals. The Offset float input defines how far away the normal details extend from the surface, and the Strength float input multiplies the size of the result. The output is a Vector 3 representing the calculated normal vector.","textRus":"Нод Normal From Texture принимает текстуру, сэмплер и набор UV в качестве входных данных и использует их в качестве карты высот, из которой он будет генерировать нормали. Входное значение «Смещение с плавающей запятой» определяет, насколько далеко нормальные детали простираются от поверхности, а входное значение с плавающей запятой «Сила» умножает размер результата. Выходными данными являются вектор 3, представляющий вычисленный вектор нормали."}},{"model":"main.shader","pk":174,"fields":{"title":"₁₈₀ Normal From Height","textEng":"The Normal From Height node is similar, except it takes in a singular height value and generates a normal vector based on the that and the input Strength float. We can change the Space used for the output normals between Tangent and World. Tangent is useful for working with textures, whereas World is great for working with lighting.","textRus":"Узел Normal From Height аналогичен, за исключением того, что он принимает единственное значение высоты и генерирует вектор нормали на основе этого значения и входного числа с плавающей запятой Strength. Мы можем изменить пространство, используемое для выходных нормалей между касательной и миром. Tangent полезен для работы с текстурами, тогда как World отлично подходит для работы с освещением."}},{"model":"main.shader","pk":175,"fields":{"title":"₁₈₁ Normal Blend","textEng":"The Normal Blend node takes in two normals, adds them together, normalises them and returns the result. This is great for combining a base normal texture, A, and a detail normal texture, B, together. We have the choice of two modes here: Default does what I just described, and Reoriented will rotate the normal by the angle between the first and second map. By doing that, the detail normal texture isn’t just layered on top of the base normal texture – it acts as if the detail normal texture is mapped onto the surface described by the base normal.","textRus":"Узел Normal Blend принимает две нормали, складывает их вместе, нормализует и возвращает результат. Это отлично подходит для объединения базовой текстуры нормалей A и текстуры деталей нормалей B вместе. Здесь у нас есть выбор из двух режимов: «По умолчанию» делает то, что я только что описал, и «Переориентация» будет вращать нормаль на угол между первой и второй картой. При этом детальная текстура нормали не просто накладывается поверх базовой текстуры нормали — она действует так, как если бы детальная текстура нормали накладывалась на поверхность, описываемую базовой нормалью."}},{"model":"main.shader","pk":176,"fields":{"title":"₁₈₂ Normal Reconstruct Z","textEng":"The Normal Reconstruct Z node takes in a generated normal vector as a Vector 2 and calculates what the Z component should be for the output Vector 3.","textRus":"Узел Normal Reconstruct Z принимает сгенерированный вектор нормали в качестве вектора 2 и вычисляет, каким должен быть компонент Z для выходного вектора 3."}},{"model":"main.shader","pk":177,"fields":{"title":"₁₈₃ Colorspace Conversion","textEng":"The Colorspace Conversion node can be used to convert an input color between the RGB, HSV and Linear color spaces. We have two dropdown options to pick the Input and Output color spaces.","textRus":"Узел преобразования цветового пространства можно использовать для преобразования входного цвета между цветовыми пространствами RGB, HSV и линейным. У нас есть два раскрывающихся списка для выбора входного и выходного цветовых пространств."}},{"model":"main.shader","pk":178,"fields":{"title":"₁₈₄ Checkerboard","textEng":"The Checkerboard node creates an alternating pattern of tiles, colored according to the Color A and Color B inputs. The UV is used for mapping the pattern onto objects and the Frequency Vector 2 is used for scaling the checkboard in those respective axes. The output is the checkerboard color as a Vector 3, although as of this article, the documentation accidentally lists the output as a UV Vector 2.","textRus":"Узел «Шахматная доска» создает чередующийся узор из плиток, окрашенных в соответствии с входными параметрами «Цвет A» и «Цвет B». UV используется для отображения узора на объектах, а вектор частоты 2 используется для масштабирования шахматной доски по соответствующим осям. На выходе получается цвет шахматной доски в формате Vector 3, хотя в этой статье в документации случайно указан вывод как UV Vector 2."}},{"model":"main.shader","pk":179,"fields":{"title":"₁₈₅ Simple Noise","textEng":"The Simple Noise node generates a basic type of noise pattern called “value noise”, using a UV input to map the noise onto your mesh and a Scale input float to rescale the noise texture in both directions. The output is a single float representing a noise value between 0 and 1.","textRus":"Нод «Простой шум» генерирует базовый тип шаблона шума, называемый «шумом значения», используя вход UV для отображения шума на сетке и входной плавающий элемент «Масштаб» для изменения масштаба текстуры шума в обоих направлениях. Выходные данные представляют собой одно число с плавающей запятой, представляющее значение шума от 0 до 1."}},{"model":"main.shader","pk":180,"fields":{"title":"₁₈₆ Gradient Noise","textEng":"The Gradient Noise node generates a slightly more sophisticated type of noise called Perlin Noise using the same UV and Scale inputs as Simple Noise, and a single float output once again. Perlin Noise is a very common type of noise used in random generation, particularly for textures and terrains.","textRus":"Узел «Градиентный шум» генерирует немного более сложный тип шума, называемый «Шум Перлина», используя те же входные параметры UV и Scale, что и «Простой шум», и снова один выход с плавающей запятой. Шум Перлина — очень распространенный тип шума, используемый при случайной генерации, особенно для текстур и ландшафтов."}},{"model":"main.shader","pk":181,"fields":{"title":"₁₈₇ Voronoi","textEng":"The Voronoi node is a very pretty and versatile type of noise. It works by generating points on a grid, repositioning them in random directions, then coloring each pixel in the grid based on distance from a point – the closer to a point we are, the darker the pixel is. We supply a UV for mapping the texture, plus an Angle Offset float for randomly moving the points and a Cell Density float to decide the number of points that are added. The Out output just gives the distance from the closest point as a float, which is usually used as the Voronoi pattern. The Cells output gives us what Unity calls the “raw cell data”, although reading the autogenerated code in the documentation, it seems to be colored based on the random x offset for each cell.","textRus":"Узел Вороного — очень красивый и универсальный тип шума. Он работает путем создания точек на сетке, перемещения их в случайных направлениях, а затем окрашивания каждого пикселя в сетке в зависимости от расстояния от точки — чем ближе мы к точке, тем темнее пиксель. Мы предоставляем UV для отображения текстуры, а также поплавок Angle Offset для случайного перемещения точек и поплавок Cell Density для определения количества добавляемых точек. Выходные данные Out просто дают расстояние от ближайшей точки в виде числа с плавающей запятой, которое обычно используется в качестве шаблона Вороного. Вывод ячеек дает нам то, что Unity называет «необработанными данными ячейки», хотя, читая автоматически сгенерированный код в документации, кажется, что они окрашены в зависимости от случайного смещения x для каждой ячейки."}},{"model":"main.shader","pk":182,"fields":{"title":"₁₈₈ Rectangle","textEng":"The Rectangle node takes an input UV and a Width and Height float, then generates a rectangle with that width and height. The width and height should be between 0 and 1, and if you use the same value for both, you should get a square texture. The output of the node is 1 if the pixel is within the rectangle, and 0 otherwise. These shapes can only be generated in the fragment stage.","textRus":"Узел Rectangle принимает входные UV и плавающие значения Width и Height, а затем генерирует прямоугольник с этой шириной и высотой. Ширина и высота должны быть от 0 до 1, и если вы используете одно и то же значение для обоих, вы должны получить квадратную текстуру. Выход узла равен 1, если пиксель находится внутри прямоугольника, и 0 в противном случае. Эти формы могут быть созданы только на этапе фрагмента."}},{"model":"main.shader","pk":183,"fields":{"title":"₁₈₉ Rounded Rectangle","textEng":"The Rounded Rectangle node is exactly the same as Rectangle, except it adds a Radius float option to specify how much the corners of the rectangle shape should be rounded.","textRus":"Узел «Прямоугольник со скругленными углами» точно такой же, как и «Прямоугольник», за исключением того, что он добавляет плавающую опцию «Радиус», позволяющую указать, насколько углы прямоугольника должны быть скруглены."}},{"model":"main.shader","pk":184,"fields":{"title":"₁₉₀ Ellipse","textEng":"The Ellipse node similarly takes a Width and Height float and a UV Vector 2 and will generate an ellipse. If you give it an equal width and height, you’ll end up with a circle.","textRus":"Узел «Эллипс» аналогичным образом принимает плавающие значения «Ширина» и «Высота» и UV-вектор 2 и генерирует эллипс. Если вы придадите ему одинаковую ширину и высоту, у вас получится круг."}},{"model":"main.shader","pk":185,"fields":{"title":"₁₉₁ Polygon","textEng":"The Polygon node uses those same Width, Height and UV inputs, and also adds a Sides input which defines how many edges the shape has. The result will be a regular polygon that’s been stretched if the width and height are different.","textRus":"Узел «Многоугольник» использует те же входные параметры «Ширина», «Высота» и «УФ», а также добавляет входные данные «Стороны», которые определяют, сколько ребер имеет форма. Результатом будет правильный многоугольник, растянутый, если ширина и высота различаются."}},{"model":"main.shader","pk":186,"fields":{"title":"₁₉₂ Rounded Polygon","textEng":"And finally, the Rounded Polygon node has the same inputs as Polygon, plus a Roundness float option which acts like the radius option on Rounded Rectangle.","textRus":"И, наконец, узел Rounded Polygon имеет те же входные данные, что и Polygon, плюс плавающую опцию Roundness, которая действует как опция радиуса Rounded Rectangle."}},{"model":"main.shader","pk":187,"fields":{"title":"₁₉₃ Preview","textEng":"The Preview node takes in a vector input and outputs precisely the same thing. The reason for using this node is that it displays what your shader looks like at this point, so it’s extremely useful for visually debugging your shaders. In previous versions of Shader Graph which didn’t feature Redirect Nodes, which you can add by double-clicking an edge, Preview nodes used to have a secondary use for redirecting edges in particularly messy graphs.","textRus":"Узел предварительного просмотра принимает векторный входной сигнал и выводит то же самое. Причина использования этого узла заключается в том, что он отображает то, как выглядит ваш шейдер на данный момент, поэтому он чрезвычайно полезен для визуальной отладки ваших шейдеров. В предыдущих версиях Shader Graph, в которых не было узлов перенаправления, которые можно было добавить, дважды щелкнув ребро, узлы предварительного просмотра имели вторичное применение для перенаправления ребер в особенно запутанных графах."}},{"model":"main.shader","pk":188,"fields":{"title":"₁₉₄ Redirect","textEng":"Double-click on any wire between node inputs/outputs and you’ll create a Redirect node between them. It has no effect on the shader output, but you can move the Redirect node around clean up your graph.","textRus":"Дважды щелкните любой провод между входами/выходами узла, и вы создадите узел перенаправления между ними. Это не влияет на выходные данные шейдера, но вы можете переместить узел Redirect, чтобы очистить график."}},{"model":"main.shader","pk":189,"fields":{"title":"₁₉₅ Keyword","textEng":"These are listed in their own section in the Create Node menu, but I’ll talk about them here. Whenever you drag a Keyword node onto the graph, which are based on whatever Keyword properties you’ve added, it will have a number of inputs and a single output. Depending on the value of the keyword defined on this material in the Inspector, a keyword node will pick whatever was input to the corresponding keyword option. For example, if we use a Boolean keyword, we can connect a range of nodes to both the On and Off inputs and the output is chosen based on the value of the keyword.","textRus":"Они перечислены в отдельном разделе меню «Создать узел», но я расскажу о них здесь. Всякий раз, когда вы перетаскиваете узел «Ключевое слово» на график, основанный на добавленных вами свойствах ключевого слова, он будет иметь несколько входных данных и один выходной. В зависимости от значения ключевого слова, определенного для этого материала в Инспекторе, узел ключевого слова выберет все, что было введено в соответствующую опцию ключевого слова. Например, если мы используем логическое ключевое слово, мы можем подключить диапазон узлов как к входам «Вкл.», так и к «Выкл.», а выход выбирается на основе значения ключевого слова."}},{"model":"main.shader","pk":190,"fields":{"title":"₁₉₆ Sub Graph","textEng":"These are also in a separate section like Keyword nodes. A Sub Graph is a separate kind of Shader Graph we can create. They have their own output nodes, which we can add outputs to, and when we add properties to a sub graph, they become the inputs to the resulting Sub Graph node. Then we can create nodes in the usual way on the graph. Once we’ve created a sub graph, we can search for them in our main graph and use them like any other node – the properties of the sub graph appear as the inputs on the left, and the outputs inside the sub graph appear as the outputs on the right of the node.","textRus":"Они также находятся в отдельном разделе, например, «Узлы ключевых слов». Подграф — это отдельный вид шейдерного графа, который мы можем создать. У них есть свои собственные выходные узлы, к которым мы можем добавлять выходные данные, а когда мы добавляем свойства в подграф, они становятся входными данными для результирующего узла подграфа. Затем мы можем обычным способом создавать узлы на графе. После того, как мы создали подграф, мы можем искать их в нашем основном графе и использовать их как любой другой узел — свойства подграфа отображаются как входные данные слева, а выходные данные внутри подграфа отображаются как выходы справа от узла."}},{"model":"main.shader","pk":191,"fields":{"title":"₁₉₇ Custom Function","textEng":"The Custom Function node lets us write custom shader code to run inside the node. I won’t go into detail here because this node is probably one of the most complicated and bespoke of them all, but if we click on the Node Settings, we can define a list of inputs and outputs of whatever types we like, and then we can attach a shader code file or write code directly into the settings window. That custom code is written in HLSL and we can write the name of the specific function from the file to use for this node.","textRus":"Узел «Пользовательская функция» позволяет нам писать собственный код шейдера для запуска внутри узла. Я не буду здесь вдаваться в подробности, потому что этот узел, вероятно, один из самых сложных и сделанных на заказ из всех, но если мы нажмем на «Настройки узла», мы сможем определить список входов и выходов любых типов, которые нам нравятся, а затем мы можем прикрепить файл кода шейдера или написать код прямо в окне настроек. Этот специальный код написан на HLSL, и мы можем записать имя конкретной функции из файла, чтобы использовать его для этого узла."}},{"model":"main.shader","pk":192,"fields":{"title":"₁₉₈ And","textEng":"The And node takes two Boolean values which can be true or false, 1 or 0. If they are both true, or 1, then this node returns true. Else, the node returns false.","textRus":"Узел И принимает два логических значения, которые могут быть истинными или ложными, 1 или 0. Если они оба истинны или 1, то этот узел возвращает истину. В противном случае узел возвращает false."}},{"model":"main.shader","pk":193,"fields":{"title":"₁₉₉ Or","textEng":"The Or node also takes two Boolean inputs. If either or both of them is true, then the node outputs true. Else, it outputs false.","textRus":"Узел Или также принимает два логических входа. Если один из них или оба верны, то узел выводит true. В противном случае он выводит false."}},{"model":"main.shader","pk":194,"fields":{"title":"₂₀₀ Not","textEng":"The Not node takes a single input and returns the opposite value. In other words, if true is input, false is output.","textRus":"Узел Not принимает один входной сигнал и возвращает противоположное значение. Другими словами, если на входе указано true, на выходе будет false."}},{"model":"main.shader","pk":195,"fields":{"title":"₂₀₁ Nand","textEng":"The Nand node is equivalent to doing And, then passing the result into a Not node. If both inputs are true, the output is false. Else the output is true. At least, in theory - the actual outputs of this node seem to act like a Nor operation, not Nand. Strange.","textRus":"Узел Nand эквивалентен выполнению операции And с последующей передачей результата в узел Not. Если оба входа истинны, выход — ложь. В противном случае вывод верен. По крайней мере, теоретически — фактические выходы этого узла действуют как операция Nor, а не Nand. Странный."}},{"model":"main.shader","pk":196,"fields":{"title":"₂₀₂ All","textEng":"The All node takes in a vector of values. If every element is non-zero, the output of the node is true.","textRus":"Узел «Все» принимает вектор значений. Если каждый элемент ненулевой, вывод узла истинен."}},{"model":"main.shader","pk":197,"fields":{"title":"₂₀₃ Any","textEng":"On the other hand, the Any node also takes in a vector, and returns true if any of the input elements are non-zero.","textRus":"С другой стороны, узел Any также принимает вектор и возвращает true, если какой-либо из входных элементов не равен нулю."}},{"model":"main.shader","pk":198,"fields":{"title":"₂₀₄ Comparison","textEng":"The Comparison node is used to compare the values of two input floats. Based on the Comparison operator chosen from the dropdown in the middle of the node, a Boolean value is output. Those operations are Equal, Not Equal, Less, Less Or Equal, Greater, Greater Or Equal. For instance, if the two inputs are 7 and 5 and your operation is Greater, then the output is True.","textRus":"Узел сравнения используется для сравнения значений двух входных чисел с плавающей запятой. На основе оператора сравнения, выбранного из раскрывающегося списка в середине узла, выводится логическое значение. Это операции «Равно», «Не равно», «Меньше», «Меньше или равно», «Больше», «Больше или равно». Например, если входные данные — 7 и 5, а ваша операция — «Больше», то выход — «Истина»."}},{"model":"main.shader","pk":199,"fields":{"title":"₂₀₅ Branch","textEng":"The Branch node can be used to take decisions in your shader, similar to an if-statement in C#. If the Input predicate is true, this node takes the value of whatever is plugged into the True input. Otherwise, it outputs whatever is in the False input. Beware that both sides will be fully calculated and the invalid branch is discarded, so it’s not a good idea to have huge node trees plugged into both True and False. If possible, move this check as early on in the graph as you can to minimise the size of the node tree plugged into both sides.","textRus":"Узел Branch можно использовать для принятия решений в шейдере, аналогично оператору if в C#. Если предикат Input имеет значение true, этот узел принимает значение всего, что подключено к входу True. В противном случае он выводит то, что находится на входе False. Помните, что обе стороны будут полностью рассчитаны, а недействительная ветвь будет отброшена, поэтому не рекомендуется подключать огромные деревья узлов одновременно к True и False. Если возможно, переместите эту проверку как можно раньше в граф, чтобы минимизировать размер дерева узлов, подключенного к обеим сторонам."}},{"model":"main.shader","pk":200,"fields":{"title":"₂₀₆ Is NaN","textEng":"The Is NaN node is shorts for “Is not a number”. In floating-point arithmetic, NaN is a special value representing an invalid number. This node returns true if the input float is NaN, and false otherwise.","textRus":"Узел Is NaN является сокращением от «Не является числом». В арифметике с плавающей запятой NaN — это специальное значение, представляющее недопустимое число. Этот узел возвращает true, если входное число с плавающей запятой равно NaN, и false в противном случае."}},{"model":"main.shader","pk":201,"fields":{"title":"₂₀₇ Is Infinite","textEng":"Similarly, Infinite is a special value that floating points can take. The Is Infinite node returns true if the input is infinite.","textRus":"Аналогично, Infinite — это особое значение, которое могут принимать плавающие точки. Узел Is Infinite возвращает true, если входные данные бесконечны."}},{"model":"main.shader","pk":202,"fields":{"title":"₂₀₈ Is Front Face","textEng":"A mesh defines whether faces are front-facing or back-facing based on the winding order of its vertices. That means the order the vertices are listed in the mesh data. The Is Front Face node will always return true unless the Two Sided option is ticked in the Graph Settings. But when it is ticked, we can decide to change the behaviour of the shader based on the facing direction of the mesh.","textRus":"Сетка определяет, являются ли грани обращенными вперед или назад, в зависимости от порядка намотки ее вершин. Это означает порядок, в котором вершины перечислены в данных сетки. Узел Is Front Face всегда будет возвращать значение true, если в настройках графика не установлен флажок «Двусторонний». Но когда он отмечен галочкой, мы можем решить изменить поведение шейдера в зависимости от направления обращения сетки."}},{"model":"main.shader","pk":203,"fields":{"title":"Supporters","textEng":"Support me on Patreon or buy me a coffee on Ko-fi for PDF versions of each article and to access certain articles early! Some tiers also get early access to my YouTube videos or even copies of my asset packs!","textRus":"Поддержите меня на Patreon или купите мне кофе на Ko-fi, чтобы получить PDF-версии каждой статьи и ранний доступ к определенным статьям! Некоторые уровни также получают ранний доступ к моим видео на YouTube или даже к копиям моих пакетов ресурсов!"}}]